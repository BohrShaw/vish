" This is the Vim(Neovim) initialization file dependent on various bundles.
" It's sourced in "vimrc".
"
" Author: Bohr Shaw <pubohr@gmail.com>

" Fundamental: {{{1

" Select bundles carefully and customize properly.
" Be aware of possible autocmd pollution which should be more concerned.

let $MYBUNDLE = expand('<sfile>') " like $MYVIMRC

call bundle#init() " bundle initialization

" Define an autocmd group and clean it
augroup bundle
  autocmd!
augroup END

" Let the bundle manager define a variable to download ALL bundles even if the
" invoked Vim binary doesn't have all these features.
let s:vf = get(g:, '_vim_with_all_features')
let s:nvim = s:vf ? 1 : has('nvim')
let s:pythonx = s:vf ? 1 : (has('python') || has('python3'))
let s:ruby = s:vf ? 1 : has('ruby')
let s:lua = s:vf ? 1 : has('lua')

" Mappings for managing bundles
autocmd bundle BufReadPost {.,}vimrc.bundle call s:bundle_map()
function! s:bundle_map()
  " Move between bundles
  nnoremap <buffer> <silent> ]<Tab> :call search('[BD]undle\a*(.\zs\C')<CR>
  nnoremap <buffer> <silent> [<Tab> :call search('[BD]undle\a*(.\zs\C', 'b')<CR>
  " Open a bundle's URL in the browser
  nnoremap <buffer> <silent> gX "zya'
        \:execute 'silent OpenBrowserSmartSearch https://github.com/'
        \.matchstr(@z, '\v''-?\zs[^'']*')<CR>
  " Activate the bundle under the cursor line
  nnoremap <buffer><silent> <LocalLeader>b mz"zyi'
        \:call BundleRun(@z)<CR>g`z
endfunction

" Debugging
command! -nargs=? -complete=command VimNORC execute
      \ v:progname.<q-args> =~ '^\S*gvim\s' ? "B!" : "Start"
      \ empty(<q-args>) ? expand(exepath(v:progpath)) : <q-args>
      \ '-u' expand('~/.vim/vimrc.min')
" Profiling
command! -nargs=? -complete=command StartupTime execute
      \ v:progname.<q-args> =~ '^\S*gvim\s' ? "B!" : "Start"
      \ empty(<q-args>) ? expand(exepath(v:progpath)) : <q-args>
      \ '--startuptime startup.log +qall!' |
      \ tab drop startup.log
command! -nargs=? -complete=command Profile execute
      \ v:progname.<q-args> =~ '^\S*gvim\s' ? "B!" : "Start"
      \ empty(<q-args>) ? expand(exepath(v:progpath)) : <q-args>
      \ '--cmd "profile start '.getcwd().'/profile.log | profile file *"'
      \ '-c "profdel file * | qall!"' |
      \ tab drop profile.log
command! ProfileTabular call profile#tabular()

" A Vim plugin for Vim plugins
call BundleRun('tpope/vim-scriptease')

" Shortcuts: {{{1

" Pairs of handy bracket mappings
call BundleRun('Tpope/vim-unimpaired')
" Move lines (fix auto-closing folds)
nnoremap <silent>[e :<C-u>call <SID>move('--', v:count1)<CR>
nnoremap <silent>]e :<C-u>call <SID>move('+', v:count1)<CR>
xnoremap <silent>[e :<C-u>call <SID>move("'<--", v:count1)<CR>
xnoremap <silent>]e :<C-u>call <SID>move("'>+", v:count1)<CR>
function! s:move(cmd, count) abort
  normal! m`
  execute 'set foldmethod=manual|'.
        \(a:cmd =~ '[<>]'?"'<,'>":'').'move'.a:cmd.a:count.
        \'|set foldmethod='.&foldmethod
  normal! ``
  silent! call repeat#set(a:cmd =~ '+' ? ']e' : '[e', a:count)
endfunction
nnoremap <silent>]d :call search('\cto-\?do:', 's')<CR>
nnoremap <silent>[d :call search('\cto-\?do:', 'sb')<CR>
nnoremap <silent>[r :set readonly<CR>
nnoremap <silent>]r :set noreadonly<CR>
nnoremap <silent>coh :let v:hlsearch = !v:hlsearch<CR>
nnoremap <silent>coM :let &mouse = empty(&mouse) ? 'a' : ''<CR>
nmap coP <Plug>unimpairedPaste

" Create your own submodes (e.g, g--- instead of g-g-g-)
" call BundlePath('kana/vim-submode')

" Mappings for simultaneously pressed keys
" call Bundles('kana/vim-arpeggio')

" Motion: {{{1

" The missing motion for Vim
if Bundles('-Justinmk/vim-sneak', 'Bohrshaw/vim-sneak')
  " Arbitrary precise motion
  nnoremap <silent> L :<C-u>call Sneak('', 0, 'n')<CR>
  xnoremap <silent> L :<C-u>call Sneak('', 0, 'v')<CR>
  onoremap <silent> L :<C-u>call Sneak('', 0, 'o')<CR>
  nnoremap <silent> H :<C-u>call Sneak('', 1, 'n')<CR>
  xnoremap <silent> H :<C-u>call Sneak('', 1, 'v')<CR>
  onoremap <silent> H :<C-u>call Sneak('', 1, 'o')<CR>
  " Within the current line
  NXOmap <expr>9f v#setvar('g:sneak#oneline', 1).'L'
  NXOmap <expr>8f v#setvar('g:sneak#oneline', 1).'H'
  function! Sneak(pattern, reverse, mode)
    if a:mode =~# "^[vV\<C-v>]"
      execute 'normal!' (v:count > 0 ? v:count : '').'gv'
    endif
    if v:count > 0
      execute 'normal!' v:count.(a:reverse == 0 ? 'L' : 'H')
      return
    endif
    let c = v#getchar()
    if empty(c) |return |endif
    if empty(a:pattern)
      if c =~# '\v^(\d|\a)$' " to match a boundary
        let p = c =~# '\d' ? '\d' : (c =~# '\l' ? '\l' : '\u')
        let pattern = '\v'.p.'@<!'.c.'|'.c.p.'@!'
      elseif c == "\<BS>" " get a new character, to match a non-boundary
        let c = v#getchar()
        let p = c =~# '\d' ? '\d' : (c =~# '\l' ? '\l' : '\u')
        let pattern = '\v'.p.'\zs'.c.'\ze'.p
      elseif c == "\<CR>" " to match the first non-blank character of a line
        let pattern = '\_^\s*\zs'
      else " to match a literal
        let c = escape(c, '\')
        let pattern = '\V'.c.'\@<!'.c.'\|'.c.c.'\@!'
      endif
    else
      let pattern = substitute(a:pattern, '\CIN', c, 'g')
    endif
    " op, input, inputlen, count, repeatmotion, reverse, inclusive, streak
    " inclusive: 2 means inclusive-exclusive motion like /
    call sneak#to('', '\m'.pattern, 1, 1, 0, a:reverse, 2, 1)
    let g:sneak#oneline = 0
  endfunction
  " Mimic the native search command / and ?, but literal
  " Function signature: sneak#wrap(op, inputlen, reverse, inclusive, streak)
  nnoremap <silent> z/ :<C-U>call sneak#wrap('', 99, 0, 2, 1)<CR>
  nnoremap <silent> z? :<C-U>call sneak#wrap('', 99, 1, 2, 1)<CR>
  xnoremap <silent> z/ :<C-U>call sneak#wrap(visualmode(), 99, 0, 2, 1)<CR>
  xnoremap <silent> z? :<C-U>call sneak#wrap(visualmode(), 99, 1, 2, 1)<CR>
  onoremap <silent> z/ :<C-U>call sneak#wrap(v:operator, 99, 0, 2, 1)<CR>
  onoremap <silent> z? :<C-U>call sneak#wrap(v:operator, 99, 1, 2, 1)<CR>
  " Repeat
  nnoremap <silent>; :<C-u>call SneakRepeat('', 0)<CR>
  xnoremap <silent>; :<C-u>call SneakRepeat(visualmode(), 0)<CR>
  onoremap <silent>; :<C-u>call SneakRepeat(v:operator, 0)<CR>
  nnoremap <silent>, :<C-u>call SneakRepeat('', 1)<CR>
  xnoremap <silent>, :<C-u>call SneakRepeat(visualmode(), 1)<CR>
  onoremap <silent>, :<C-u>call SneakRepeat(v:operator, 1)<CR>
  function! SneakRepeat(op, reverse) abort " adjusted from sneak#rpt()
    let st = sneak#state()
    if st.rst
      execute 'normal!' (a:op =~? "[v\<C-v>]" ? 'gv' : '').v:count1.(a:reverse ?
            \ !exists('*getcharsearch') || getcharsearch().forward ? ',' : ';' :
            \ !exists('*getcharsearch') || getcharsearch().forward ? ';' : ',')
    else
      call sneak#to(a:op, st.input, st.inputlen, v:count1, 1, a:reverse, st.inclusive, 0)
    endif
  endfunction
  if !exists('*getcharsearch') " Vim patch 7.4.813
    " To make the repeat direction absolute, it's easy to accomplish this with
    " the built-in mappings, though I dislike the multi-lines behavior.
    NXOmap f <Plug>Sneak_f
    NXOmap F <Plug>Sneak_F
    NXOmap t <Plug>Sneak_t
    NXOmap T <Plug>Sneak_T
  endif "}}}
  let g:sneak#streak = 1 " enable streak mode
  " let g:sneak#streak_esc = "\<CR>" " key to exit streak-mode
  let g:sneak#absolute_dir = 1 " always go forwards or backwards when repeating
  " let g:sneak#use_ic_scs = 1 " ignorecase and smartcase
  hi! link SneakPluginScope Comment
  " Disable default mappings
  NXOmap <Plug>_Sneak_s <Plug>Sneak_s
  NXOmap <Plug>_Sneak_S <Plug>Sneak_S
  let sneak#textobject_z = 0 " prevent the default {operator}z mapping
elseif Bundles('machakann/vim-patternjump')
  let g:patternjump_no_default_key_mappings = 1
elseif Bundles('lokaltog/vim-easymotion')
  let g:EasyMotion_leader_key = 'g<CR>'
elseif Bundles('-goldfeld/vim-seek', '-rhysd/clever-f.vim')
  let g:SeekKey = 'f<CR>'
  let g:SeekBackKey = 'f<BS>'
  " let g:seek_enable_jumps = 1
  let g:clever_f_across_no_line = 1
endif

" Create your own text objects
if BundlePath('Kana/vim-textobj-user')
  call textobj#user#plugin('file', {
        \ 'file': {
        \ 'pattern': '\f\+', 'select': ['af', 'if']
        \ }
        \ })
endif

" Text objects extended, more sensible, and corner cases handled
" Cheatsheet: ~/.vim/bundle/targets.vim/cheatsheet.md
if Dundles('Wellle/targets.vim') && Bundles('tommcdo/vim-ninja-feet',
      \ '-gaving/vim-textobj-argument', '-b4winckler/vim-angry',
      \ 'kana/vim-textobj-indent', '-qstrahl/vim-dentures',
      \ 'machakann/vim-textobj-delimited', 'coderifous/textobj-word-column.vim')
  " Delay activating this bundle to reduce startup time
  if has('vim_starting')
    set updatetime=10
    augroup bundle_targets
      autocmd CursorHold * call BundleRun("targets.vim") |
            \ set updatetime& | autocmd! bundle_targets CursorHold
    augroup END
  endif
endif

" Search: {{{1

" Search improved
if Bundles('Haya14busa/incsearch.vim', 'Haya14busa/vim-asterisk')
  " Highlight will auto-suspend on cursor move after a search
  nnoremap <expr>/ incsearch#autocmd#auto_nohlsearch(1).'ms/'
  nnoremap <expr>? incsearch#autocmd#auto_nohlsearch(1).'ms?'
  xnoremap <expr>/ incsearch#autocmd#auto_nohlsearch(1).'/'
  xnoremap <expr>? incsearch#autocmd#auto_nohlsearch(1).'?'
  onoremap <expr>/ incsearch#autocmd#auto_nohlsearch(1).'/'
  onoremap <expr>? incsearch#autocmd#auto_nohlsearch(1).'?'
  " Suspend or temporarily resume highlight, primarily for :s, :g
  nnoremap <silent>zh :<C-u>if v:hlsearch \|nohlsearch \|
        \else \|call incsearch#autocmd#auto_nohlsearch(0) \|set hlsearch \|endif<CR>
  xmap zh <Esc>zhgv
  " Consistent direction when repeating a search
  NXOnoremap <expr>n incsearch#autocmd#auto_nohlsearch(1).
        \(v:searchforward ? 'n' : 'N').'zv'
  NXOnoremap <expr>N incsearch#autocmd#auto_nohlsearch(1).
        \(v:searchforward ? 'N' : 'n').'zv'
  " let g:incsearch#consistent_n_direction = 1 " redundant
  " Incremantal search improved with a search specific command line interface
  map g/ <Plug>(incsearch-forward)
  map g? <Plug>(incsearch-backward)
  function! s:incsearch_mapping()
    IncSearchNoreMap <M-j> <Over>(incsearch-next)
    IncSearchNoreMap <M-k> <Over>(incsearch-prev)
    IncSearchNoreMap <C-f> <Over>(incsearch-scroll-f)
    IncSearchNoreMap <C-b> <Over>(incsearch-scroll-b)
    IncSearchNoreMap <Tab> <Over>(buffer-complete)
    IncSearchNoreMap <S-Tab> <Over>(buffer-complete-prev)
  endfunction
  execute repeat('autocmd bundle VimEnter * ', has('vim_starting')).
        \'call s:incsearch_mapping()'
  " Search literally in visual mode
  map <expr>*  '<Plug>(incsearch-nohl)<Plug>(asterisk-*)zv'
  map <expr>#  '<Plug>(incsearch-nohl)<Plug>(asterisk-#)zv'
  map <expr>g* '<Plug>(incsearch-nohl)<Plug>(asterisk-g*)zv'
  map <expr>g# '<Plug>(incsearch-nohl)<Plug>(asterisk-g#)zv'
  " The cusor would not move
  map z*  <Plug>(incsearch-nohl0)<Plug>(asterisk-z*)
  map gz* <Plug>(incsearch-nohl0)<Plug>(asterisk-gz*)
  map z#  <Plug>(incsearch-nohl0)<Plug>(asterisk-z#)
  map gz# <Plug>(incsearch-nohl0)<Plug>(asterisk-gz#)
  let g:incsearch#auto_nohlsearch = 1 " auto-nohlsearch on cursor move
  " Highlight only in the current window (custom hi-group instead of 'Search')
  let g:incsearch#no_inc_hlsearch = 1
endif

" Completion: {{{1

" Provides insert mode auto-completion for quotes, parens, brackets, etc.
" Currently there're problems with 'repeat' or 'undo'.
call Bundles('-raimondi/delimitmate', '-cohama/lexima.vim', '-jiangmiao/auto-pairs')

" Wisely add 'end' in ruby, endfunction/endif/more in vim script, etc
call Bundles('tpope/vim-endwise')

" Completions
if s:lua && Bundles('shougo/neocomplete.vim', 'bohrshaw/vimproc.vim')
  let g:neocomplete#enable_at_startup = 0
  let g:neocomplete#max_list = 20
  let g:neocomplete#auto_completion_start_length = 2
  let g:neocomplete#manual_completion_start_length = 1
  " let g:neocomplete#min_keyword_length = 3
  let g:neocomplete#enable_smart_case = &smartcase
  " let g:neocomplete#enable_cursor_hold_i = 1
  " let g:neocomplete#cursor_hold_i_time = 400 " same as swap saving interval
  let g:neocomplete#lock_iminsert = 1
  " let g:neocomplete#enable_prefetch = 1
  let g:neocomplete#data_directory = '~/.vim/tmp/neocomplete'
  " let g:neocomplete#release_cache_time = 1800 " seconds
  " Enable/disable neocomplete
  nnoremap <expr> c\C neocomplete#is_enabled() ?
        \ ':NeoCompleteDisable<CR>' : ':NeoCompleteEnable<CR>'
  " Toggle auto/manual completion for the current buffer
  nnoremap c\c :NeoCompleteToggle<CR>
  inoremap <M-g>tc <C-R>=neocomplete#commands#_toggle_lock()[1:0]<CR>
  " Start manual completion
  inoremap <silent><M-n> <C-O>:call neocomplete#init#enable() \|
        \call neocomplete#commands#_lock() \|
        \inoremap <silent><expr><M-n> neocomplete#start_manual_complete()<CR>
        \<C-R>=neocomplete#start_manual_complete()<CR>
elseif Bundles('valloric/youcompleteme')
elseif Bundles('ervandew/supertab')
endif

" Snippet solutions
if s:pythonx && Bundle('Sirver/ultisnips',
      \ {'m':['i <M-[>', 'x <M-[>'], 'c':'UltiSnipsEdit', 'f':'*.snippets'}) &&
      \ Bundles('Honza/vim-snippets')
  let g:UltiSnipsExpandTrigger='<M-[>'
  imap <C-s> <M-[>
  let g:UltiSnipsListSnippets='<M-g>['
  let g:UltiSnipsJumpForwardTrigger="<M-j>"
  let g:UltiSnipsJumpBackwardTrigger="<M-k>"
  let g:UltiSnipsSnippetDirectories=["UltiSnips", "snippet"]
  let g:UltiSnipsSnippetsDir=expand("~/.vim/snippet") " personal snippets path
  " let g:UltiSnipsEditSplit="horizontal"
  " let g:UltiSnipsUsePythonVersion = has('python3') ? 3 : 2

  " Hacking (due to the limitation of Bundle())
  autocmd bundle BufNewFile,BufRead *.snippets setf snippets
  " Performance
  let g:UltiSnipsRemoveSelectModeMappings = 0
  let b:did_after_plugin_ultisnips_after = 1 " I don't have SuperTab
elseif Bundles('garbas/vim-snipmate', 'marcweber/vim-addon-mw-utils',
      \ 'tomtom/tlib_vim', 'honza/vim-snippets')
  command! -nargs=1 SImap imap <args>|smap <args>
  SImap <M-j> <Plug>snipMateNextOrTrigger
  xmap <M-j> <Plug>snipMateVisual
  SImap <M-k> <Plug>snipMateBack
  SImap <M-s> <Plug>snipMateShow
endif
let g:snips_author = 'Bohr Shaw'
let g:snips_author_email = 'pubohr@gmail.com'

" Change: {{{1

" Commenting
if Bundles('Tpope/vim-commentary', '-scrooloose/nerdcommenter', '-tomtom/tcomment_vim')
  let commentary_map_backslash = 0 " jd
  let g:tcommentMapLeader1 = '<M-c>'
  let [g:tcommentMapLeader2, g:tcommentMapLeaderCommentAnyway, g:tcommentTextObjectInlineComment] = ['', '', '']
endif

" Deal with pairs of 'surroundings'
if Bundles('Tpope/vim-surround')
  " :help ys
  nmap s      <Plug>Ysurround
  nmap ss     <Plug>Yssurround
  nmap ds     <Plug>Dsurround
  nmap cs     <Plug>Csurround
  " :help yS
  nmap gs     <Plug>YSurround
  nmap gss    <Plug>YSsurround
  nmap gcs    <Plug>CSurround
  " :help vS
  xmap s      <Plug>VSurround|xnoremap S s
  xmap gs     <Plug>VgSurround
  " :help i_CTRL-G_s
  imap <M-s>  <Plug>Isurround
  imap <M-g>s <Plug>ISurround
  cnoremap <expr><M-s> <SID>csurround()
  function! s:csurround()
    let cs = matchstr(['()b', '[]r', '{}B', '<>a', '""', "''", '``'], v#getchar(1, 1))[:1]
    return empty(cs) ? '' : cs."\<Left>"
  endfunction

  " Surround replacements
  let g:surround_101 = " \r " " e(empty) as <Space>
  let g:surround_13 = "\n\t\r\n" " <CR>
  nmap ss<CR> sVl<CR>

  " Surround targets
  " Delete the nearest <Space>s around the cursor
  nnoremap <silent>dse mz:execute 'keepp s/\v\s*(\S*%#\S*)\s*/\1'<Bar>
        \call repeat#set("dse")<CR>g`z

  let g:surround_indent = 1
  let g:surround_no_mappings = 1
endif

" Switch segments of text with predefined replacements
if Bundles('andrewradev/switch.vim')
  let g:switch_mapping = "s<CR>"
  " let g:switch_custom_definitions = []
endif

" Transition between multiline and single-line code
if Bundles('andrewradev/splitjoin.vim')
  let g:splitjoin_split_mapping = 'cS'
  let g:splitjoin_join_mapping  = 'cJ'
endif

" Alignment
if Bundles('-godlygeek/tabular', 'junegunn/vim-easy-align', '-tommcdo/vim-lion')
  command! -nargs=* -range -bang Align <line1>,<line2>EasyAlign <args>
  NXmap zl <Plug>(EasyAlign)
  NXmap Zl <Plug>(LiveEasyAlign)
endif

" Use CTRL-A/CTRL-X to increment dates, times, and more
call Bundles('tpope/vim-speeddating')

" Exchange text flexibly with a text exchange operator
if Bundles('Tommcdo/vim-exchange')
  " nmap cx <Plug>(Exchange)
  vmap cx <Plug>(Exchange)
  " nmap cxc <Plug>(ExchangeClear)
  " nmap cxx <Plug>(ExchangeLine)
  nmap >w cxiwwcxiw
  nmap <w cxiwbcxiw
  nmap >W cxiWWcxiW
  nmap <W cxiWBcxiW
  nmap >a cxiaf,lcxia
  nmap <a cxiaF,hcxia
endif

" Exchange(swap) text directly/quickly with mappings
if Bundles('-kurkale6ka/vim-swap')
  " let g:swap_custom_ops = []
  xmap c: <plug>SwapSwapOperands
  xmap c\| <plug>SwapSwapPivotOperands
endif

" Transpose matrices of text (swap lines with columns)
call Bundles('salsifis/vim-transpose')

" Easily search for, substitute, and abbreviate multiple variants of a word
call Bundles('Tpope/vim-abolish')

" True Sublime Text style multiple selections for Vim
call Bundles('kristijanhusak/vim-multiple-cursors')

" Preview contents of the registers when ", @, i_CTRL-R
" call Dundles('junegunn/vim-peekaboo')

" Make the handling of unicode and digraphs easier
if Bundles('chrisbra/unicode.vim', 'tpope/vim-characterize')
  imap <C-x><M-u> <Plug>(UnicodeComplete)
  imap <C-x><M-d> <Plug>(DigraphComplete)
  nmap gA <Plug>(UnicodeGA)
  " Disable mappings
  nmap <leader>_MakeDigraph <Plug>(MakeDigraph)
  nmap <leader>_UnicodeSwapCompleteName <Plug>(UnicodeSwapCompleteName)
  " Duplicate commands with new names
  command! -nargs=1 Unicode call unicode#PrintUnicode(<q-args>)
  command! UnicodeDownload call unicode#Download(1)
endif

" Replay the edit
" call Bundles('chrisbra/replay', 'haya14busa/vim-undoreplay')

" Repeat: {{{1

" Visualize the undo tree/history
if Bundles(s:nvim ? 'Simnalamburt/vim-mundo' : 'Sjl/gundo.vim') && Dundles('Sjl/gundo.vim')
  nnoremap <silent>c\u :GundoToggle<CR>
  nnoremap <silent>c\U :GundoRenderGraph<CR>
  autocmd bundle BufNewFile __gundo*
        \ nnoremap <buffer><expr><nowait>R
        \   ':let g:gundo_auto_preview = '.!g:gundo_auto_preview.
        \   " <Bar> normal r<CR>"|
        \ nmap <buffer><M-q> q
  let g:gundo_close_on_revert = 1 " auto-close the Gundo window
  let g:gundo_auto_preview = 0
  let g:gundo_playback_delay = 500
  " let g:gundo_help = 0
elseif Bundles('mbbill/undotree')
  nnoremap <silent><M-b>u :UndotreeToggle<CR>
  let g:undotree_SetFocusWhenToggle = 1 " cursor on the Undo window
endif

" Enable repeating supported plugin maps with '.'
call Bundles('Tpope/vim-repeat')

" A lightweight implementation of emacs's kill-ring for vim
" call Bundles('maxbrunsfeld/vim-yankstack')

" View: {{{1

" Distraction-free, hyper-focus writing
if Bundles('Junegunn/goyo.vim', 'Junegunn/limelight.vim')
  " let g:goyo_width = 100
  let g:goyo_margin_top = 2
  let g:goyo_margin_bottom = 2
  " let g:goyo_linenr = 1
  nnoremap <silent><C-W><M-o> :Goyo<CR>
  " autocmd bundle User GoyoEnter Limelight
  " autocmd bundle User GoyoLeave Limelight!
endif

" Resize windows automatically using the Golden Ratio
if Bundle('roman/golden-ratio', {'m': [
      \'nmap <C-w><M-g> <Plug>(golden_ratio_toggle)']})
  let g:golden_ratio_autocommand = 0
endif

" Content: {{{1

" Fuzzy file, buffer, mru, tag, etc finder
if Bundles('-ctrlpvim/ctrlp.vim')
  let g:ctrlp_cache_dir = $HOME.'/.vim/tmp/ctrlp'
  " Set the mode to determine the root searching directory.
  " let g:ctrlp_working_path_mode = 'ra'
  " let g:ctrlp_show_hidden = 1 " scan for dotfiles and dotdirs
  let g:ctrlp_follow_symlinks = 1
  " let g:ctrlp_clear_cache_on_exit = 0
  let g:ctrlp_max_files = 0
  let g:ctrlp_lazy_update = 99 " update the match window lazily
  " let g:ctrlp_by_filename = 1 " search by file name only
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/]\.(git|hg|svn)$',
        \ 'file': '\v\.(exe|so|dll)$'
        \ }
  " Specify an external tool to use for listing files.
  let s:ctrlp_git_cmd = 'cd %s && git ls-files --cached --others --exclude-standard'
  let g:ctrlp_user_command = {
        \ 'types': {
        \ 1: ['.git', has('win32') ? '('.s:ctrlp_git_cmd.')' : s:ctrlp_git_cmd],
        \ 2: ['.hg', 'hg --cwd %s locate -I .'],
        \ },
        \ 'fallback': !has('win32') ?
        \ 'find %s -path "*/\.*" -prune -o -type f -print -o -type l -print' :
        \ executable('ag') ? 'ag -g "" %s' : ''
        \ }
  " Mappings inside CtrlP's prompt
  let g:ctrlp_prompt_mappings = {
        \ 'PrtCurLeft()':         ['<C-b>'],
        \ 'PrtCurRight()':        ['<C-f>'],
        \ 'PrtInsert()':          ['<C-r>'],
        \ 'PrtInsert("c")':       ['<C-S-v>'],
        \ 'ToggleRegex()':        ['<M-r>'],
        \ 'ToggleByFname()':      ['<M-d>'],
        \ 'PrtSelectMove("j")':   ['<M-j>'],
        \ 'PrtSelectMove("k")':   ['<M-k>'],
        \ 'MarkToOpen()':         ['<M-m>'],
        \ 'AcceptSelection("h")': ['<M-w>s'],
        \ 'AcceptSelection("v")': ['<M-w>v'],
        \ 'AcceptSelection("t")': ['<M-w>t'],
        \ 'CreateNewFile()':      ['<C-n>'],
        \ 'ToggleType(1)':        ['<M-f>'],
        \ 'ToggleType(-1)':       ['<M-b>'],
        \ 'PrtExit()':            ['<Esc>', '<C-c>', '<M-q>', '<C-g>'],
        \ }
  " Find project files
  let g:ctrlp_map = '<M-f>p'
  " Most recent used files
  nnoremap <Leader>fr :CtrlPMRU<CR>
  " Files with similar names
  nmap <Leader>fs :let g:ctrlp_default_input = expand('%:t:r') \|
        \ call ctrlp#init(0) \| unlet g:ctrlp_default_input<CR>
  " Buffers
  nnoremap <Leader>fb :CtrlPBuffer<CR>
  " Files, buffers and MRU files at the same time
  nnoremap <Leader>fa :CtrlPMixed<CR>
  " Bookmarked directories
  nnoremap <leader>fm :CtrlPBookmarkDir<CR>
  " Clear the cache for the current search path
  nnoremap <leader>fc :CtrlPClearCache<CR>
  " fast matcher(especially for large projects) using python
  if 0 && s:pythonx && Bundles('felikz/ctrlp-py-matcher')
    let g:ctrlp_match_func = {'match': 'pymatcher#PyMatch'}
  elseif Bundles('tpope/vim-haystack') " better fuzzy matching algorithm
    function! Haystack_matcher(items, str, limit, mmode, ispath, crfile, regex) abort
      let items = copy(a:items)
      if a:ispath
        call filter(items, 'v:val !=# a:crfile')
      endif
      return haystack#filter(items, a:str)
    endfunction
    let g:ctrlp_match_func = {'match': 'Haystack_matcher'}
  endif
  " Extensions
  let g:ctrlp_extensions = []
  " Navigate and jump to function defs
  if Bundles('tacahiroy/ctrlp-funky')
    call add(g:ctrlp_extensions, 'funky')
    nnoremap <Leader>ff :CtrlPFunky<CR>
  endif
  " Modified files in git projects
  if Bundles('jasoncodes/ctrlp-modified.vim')
    nnoremap <Leader>fg :CtrlPModified<CR>
  endif
endif

" Unite and create user interfaces
if BundlePath('shougo/unite.vim') && Bundles('thinca/vim-unite-history',
      \'shougo/neomru.vim', 'shougo/unite-outline', 'tsukkee/unite-tag',
      \'shougo/unite-help', '-shougo/tabpagebuffer.vim')
  command! -nargs=* -complete=customlist,unite#complete#source U Unite <args>
  command! -nargs=? -complete=customlist,unite#complete#buffer_name Ur UniteResume <args>
  " The key <M-b> prefixes all mappings related to 'internal' contents
  nnoremap <silent><M-b>l :Unite -buffer-name=buffer buffer<CR>
  nmap <M-b>o <M-b>l
  nnoremap <silent><M-b>L :Unite -direction=above -prompt-direction=above line<CR>
  nnoremap <silent><M-b>O :Unite -direction=above -prompt-direction=above outline<CR>
  nnoremap <silent><M-b>j :Unite jump<CR>
  nnoremap <silent><M-b>c :Unite change<CR>
  nnoremap <silent><M-b>r :Unite register<CR>
  nnoremap <silent><M-b>h :Unite -buffer-name=help -input=.txt\ doc/ buffer:?<CR>
  nnoremap <silent><M-b>H :Unite help<CR>
  " The key <M-f> relates to 'external' contents
  nnoremap <silent><M-f>l :Unite file:<C-r>=escape(expand('%:h'), '\')<CR><CR>
  nnoremap <silent><M-f>L :Unite file<CR>
  nnoremap <silent><M-f>p :call <SID>project_files()<CR>
  function! s:project_files()
    let git_dir = get(b:, 'git_dir', fugitive#extract_git_dir(getcwd()))
    if !empty(git_dir)
      execute 'lcd '.git_dir[:-6]
      Unite file_rec/git:--cached:--others:--exclude-standard
    else
      execute 'Unite file_rec/'.(has('nvim')?'neovim':'async')
    endif
  endfunction
  nnoremap <silent><M-f>r :Unite file_mru<CR>
  nnoremap <silent><M-f>m :Unite bookmark<CR>
  " The key <M-u> relates to utilities or Unite itself
  nnoremap <silent><M-u>c :Unite history/command<CR>
  nnoremap <silent><M-u>m :Unite mapping:%<CR>
  nnoremap <silent><M-u>f :Unite function<CR>
  nnoremap <silent><M-u>s :Unite source<CR>
  nnoremap <silent><M-u>r :UniteResume<CR>
  nnoremap <silent>]<M-u> :UniteNext<CR>
  nnoremap <silent>[<M-u> :UnitePrevious<CR>
  " Custom mappings for unite buffers
  autocmd bundle FileType unite call <SID>unite_buffer_mapping()
  function! s:unite_buffer_mapping()
    " Navigation
    " Note <Esc> is mapped to <Plug>(unite_insert_leave) which just moves the curosr
    imap <buffer><M-x> <Esc>x
    imap <buffer><M-j> <Plug>(unite_select_next_line)
    imap <buffer><M-k> <Plug>(unite_select_previous_line)
    " Action
    inoremap <silent><buffer><expr><M-w>s unite#do_action('split')
    inoremap <silent><buffer><expr><M-w>v unite#do_action('vsplit')
    inoremap <silent><buffer><expr><M-w>t unite#do_action('tabopen')
    inoremap <silent><buffer><expr><M-e> unite#do_action('edit')
    " Mark
    unmap <buffer><Space>|unmap <buffer><S-Space>
    nmap <buffer>m <Plug>(unite_toggle_mark_current_candidate)
    nmap <buffer>M <Plug>(unite_toggle_mark_current_candidate_up)
    xmap <buffer>m v_<Plug>(unite_toggle_mark_selected_candidates)
    unmap! <buffer><Space>|unmap! <buffer><S-Space>
    imap <expr><buffer>m unite#smart_map('m', "\<Plug>(unite_toggle_mark_current_candidate)")
    imap <expr><buffer>M unite#smart_map('M', "\<Plug>(unite_toggle_mark_current_candidate_up)")
    " Quit
    imap <buffer><M-q> <Plug>(unite_exit)
    nmap <buffer><M-q> <Plug>(unite_exit)
    imap <buffer><M-Q> <Esc><Plug>(unite_all_exit)
    nmap <buffer>R <Plug>(unite_restart)
    " Others
    nmap <buffer>C <Plug>(unite_disable_max_candidates)
    imap <buffer><M-Space> <Esc>:
  endfunction
  call unite#custom#profile('default', 'context', {
        \'start_insert': 1,
        \'direction': 'belowright',
        \'prompt_direction': 'below',
        \'auto_resize': 1,
        \})
  if executable('ag')
    if has('win32')
      let g:unite_source_rec_async_command = 'ag -g ""'
    endif
    let g:unite_source_grep_command='ag'
    let g:unite_source_grep_default_opts='--line-numbers'
    let g:unite_source_grep_recursive_opt=''
  endif
  " call unite#filters#matcher_default#use(['matcher_fuzzy'])
  " let g:unite_source_history_yank_enable = 1 " yank ring
  let g:unite_data_directory = expand('~/.vim/tmp/unite')
  let g:neomru#file_mru_path = expand('~/.vim/tmp/unite/mru/files')
  let g:neomru#directory_mru_path = expand('~/.vim/tmp/unite/mru/directories')
  " Performance tuning
  " let g:neomru#do_validate = 0 " skip checking invalide files for performance
  autocmd VimEnter * silent! autocmd! neomru BufEnter,VimEnter,BufWritePost
endif

" A tree explorer plugin for vim
if Bundle('scrooloose/nerdtree', {'m': [
      \ 'nnoremap c\d :NERDTreeToggle<CR>',
      \ 'noremap <leader>dd :NERDTree<CR>',
      \ 'noremap <leader>df :NERDTreeFind<CR>']})
  let NERDTreeHijackNetrw=0 " don't replace netrw
  let NERDTreeBookmarksFile=$HOME.'/.vim/tmp/NERDTreeBookmarks'
  let NERDTreeIgnore=['^\.$', '^\.\.$', '\~$', '\.pyc$', '\.swp$']
  let NERDTreeShowHidden=1
  let NERDTreeShowBookmarks=1
  let NERDTreeQuitOnOpen=1
  let NERDTreeMouseMode=2
endif

" Convenient directory listing and file selection
if 0 && Bundles('justinmk/vim-dirvish', '-tpope/vim-vinegar', '-jeetsukumaran/vim-filebeagle')
  nmap <M-f>l <Plug>VinegarUp
  autocmd bundle VimEnter * nunmap -
endif

" Bookmarks independent from Vim marks
if Bundles('-mattesGroeger/vim-bookmarks')
  let g:bookmark_sign = 'm'
  let g:bookmark_annotation_sign = 'ma'
  " let g:bookmark_auto_save = 0
  let g:bookmark_auto_save_file = $HOME.'/.vim/tmp/bookmark'
  " let g:bookmark_highlight_lines = 1
  " let g:bookmark_center = 1
  nmap <Leader>tm <Plug>ToggleBookmark
  nmap ma <Plug>Annotate
  nmap ]m <Plug>NextBookmark
  nmap [m <Plug>PrevBookmark
  nmap <Leader>ml <Plug>ShowAllBookmarks
  nmap <Leader>mc <Plug>ClearBookmarks
  nmap <Leader>mC <Plug>ClearAllBookmarks
endif

" Project configuration
" call Bundles('tpope/vim-projectionist')

" Buffer Explorer/Browser
call Bundles('-vim-scripts/bufexplorer.zip', '-jeetsukumaran/vim-buffergator')

" Session management
if Bundles('bohrshaw/vim-mansion', '-tpope/vim-obsession')
  if has('nvim')
    augroup bundle_mansion
      autocmd CursorMovedI * SessionTrack|autocmd! bundle_mansion
    augroup END
  endif
  " let g:sessiondir = '~/.vim/session'
  " let g:mansion_no_auto_save = 1
  " let g:mansion_no_maps = 1
elseif Bundles('mhinz/vim-startify')
  let g:startify_session_dir = '~/.vim/tmp/session'
  let g:startify_list_order = ['sessions', 'bookmarks', 'files']
  let g:startify_skiplist = ['[Vv]im.*[\/]doc[\/][^\/]\+\.txt']
  let g:startify_custom_header = [
        \ '   _   /|',
        \ "   \\'o.O'",
        \ '   =(___)=',
        \ '      U    ʕϴϖϴʔ',
        \ ''
        \ ]
  " Prevent CtrlP open a split
  autocmd bundle FileType startify setlocal nospell buftype=
endif

" Appearance: {{{1

" Color Schemes
if Bundles('Junegunn/seoul256.vim', 'Bohrshaw/vim-colors',
      \ '-flazz/vim-colorschemes', '-daylerees/colour-schemes/vim',
      \ '-chriskempson/vim-tomorrow-theme', 'Chriskempson/base16-vim')
  let g:seoul256_background = has('gui_running') ? 234 : 233

  let g:solarized_italic = 0
  let g:solarized_termcolors = &term =~ '256col' ? 256 : 16
  let g:solarized_menu=0
  autocmd bundle ColorScheme solarized runtime colors/solarized_additional.vim
endif
autocmd bundle VimEnter * nested execute 'silent color'
      \ (has('gui_running') ? 'seoul256' :
      \ (has('win32') ? '' : 'seoul256'))

" Make gvim-only colorschemes work transparently in terminal vim
" call Bundles('godlygeek/csapprox')

" Configurable and extensible tab line and status line
if Bundles('tpope/vim-flagship')
  " Tabline
  let g:tabprefix = '%1*'.
        \ (has('nvim') ? matchstr(v:servername, 'nvim.*') : '%{v:servername}').
        \ (g:l ? '(L)' : '').
        \ (empty($SSH_TTY) ? '': '@'.hostname()).
        \ '%*'
  let g:tabsuffix = "%1*%{Vmode()}%*"
  " Statusline (leave untouched)
  if has('vim_starting')
    autocmd User Flags call Vstatusline()
  endif
endif

" Lean & mean statusline for vim that's light as air
if Bundles('-bling/vim-airline')
  " Remove separators, the different colors already make it easy to distinguish.
  let [g:airline_left_sep, g:airline_right_sep] = ['', '']
  " let g:airline_paste_symbol = 'P'
  let g:airline_section_z = '%l,%c %p%%' "right side section
  " Use shorter modes indicators
  let g:airline_mode_map = { '__': '-', 'n': 'N', 'i': 'I', 'R': 'R', 'c': 'C',
        \ 'v': 'V', 'V': 'VL', '': 'VB', 's': 'S', 'S': 'SL', '': 'SB'}
  " Extensions
  " Disable showing a summary of changed hunks under source control.
  let g:airline#extensions#hunks#enabled = 0
  " Showing only non-zero hunks.
  let g:airline#extensions#hunks#non_zero_only = 1
  " Disable detection of whitespace errors.
  let g:airline#extensions#whitespace#enabled = 0
  " Disable tagbar integration.
  let g:airline#extensions#tagbar#enabled = 0
endif

" Super simple vim plugin to show the list of buffers in the command bar
" call Bundles('bling/vim-bufferline')

" Toggle, display and navigate marks
if Bundles('-kshenoy/vim-signature')
  let g:SignatureEnabledAtStartup = 0
  let g:SignatureMenu = 0
endif

" Displaying indent levels visually
if Bundles('yggdroot/indentline', '-nathanaelkane/vim-indent-guides')
  let g:indentLine_enabled = 0
  let g:indentLine_fileTypeExclude = ['help']
  let g:indentLine_noConcealCursor = ''
  " let g:indentLine_fileType = ['rb']
  " let g:indentLine_faster = 1
  " let g:indentLine_char = '┊' " |│¦┆┊
  nnoremap c\i :IndentLinesToggle<CR>
endif

" A powerful color tool
call Bundles('-rykka/colorv.vim')

" All 256 xterm colors with their RGB equivalents, right in Vim!
call Bundle('guns/xterm-color-table.vim', {'c': 'XtermColorTable'})

" FileTypes: {{{1

" Mixed {{{2

" Syntax checking hacks for vim
if Bundles('scrooloose/syntastic')
  let g:syntastic_mode_map = { 'mode': 'active',
        \ 'active_filetypes': [],
        \ 'passive_filetypes': [] }
  let g:syntastic_always_populate_loc_list = 1
  " let g:syntastic_auto_jump = 3 " auto-jump to the first error
endif

" Format codes with external code formatters
if Bundles('chiel92/vim-autoformat')
endif

" Vim plugin that displays tags in a window, ordered by class etc
if Bundles('majutsushi/tagbar')
  nnoremap <silent>c\t :TagbarToggle<CR>
  nnoremap c\T :TagbarTogglePause<CR>
  let g:tagbar_map_toggleautoclose = "C"
  let g:tagbar_autoclose = 1

  let g:tagbar_map_preview = "p"
  let g:tagbar_map_showproto = "i"
  let g:tagbar_map_hidenonpublic = "P"
  let g:tagbar_map_togglesort = "S"
  let g:tagbar_sort = 0
  let g:tagbar_map_zoomwin = "X"
  let g:tagbar_zoomwidth = 0
  let g:tagbar_compact = 1
  let g:tagbar_foldlevel = 2
endif

" Documentation/reference viewer
if Bundles('keithbsmiley/investigate.vim')
  nnoremap <silent>gK :call investigate#Investigate()<CR>
endif
if 0 && Bundles('thinca/vim-ref')
  let g:ref_no_default_key_mappings = 1
  nmap gK <Plug>(ref-keyword)
  xmap gK <Plug>(ref-keyword)
endif
" Reference docs using an external tool 'zeal' (poor VimL)
if Bundle('KabbAmine/zeavim.vim', {'m': ['nnoremap zK :Zeavim<CR>']})
  " Or set a local docset with :Docset which actually just set b:manualDocset
  let g:zv_added_files_type = {
        \ 'python': 'python 3',
        \ 'ruby': 'ruby 2',
        \ }
  let g:zv_disable_mapping = 1
endif

" Dispatch.vim: asynchronous build and test dispatcher
call Bundles('tpope/vim-dispatch')

" Execute whole/part of editing file
if Bundles('thinca/vim-quickrun')
  let g:quickrun_config = {'_': {'outputter': 'message'}}
  let g:quickrun_no_default_key_mappings = 1
  nmap R <Plug>(quickrun-op)
  nnoremap <silent> Rr :Run -mode n<CR>
  nnoremap RR :%QuickRun -mode n<CR>
  xnoremap R :QuickRun -mode v<CR>
  command! -nargs=* -range -complete=customlist,quickrun#complete Run
        \ call quickrun#command(<q-args>, <count>, <line1>, <line2>)
endif

" Markups {{{2

" HTML5 omnicomplete and syntax
call Bundles('othree/html5.vim')

" Runtime files for Haml, Sass, and SCSS
call Bundles('tpope/vim-haml')

" XML
let g:xml_syntax_folding = 1

" Runtime files for LESS (dynamic CSS)
call Bundles('groenewege/vim-less')

" Improves HTML & CSS workflow: http://emmet.io
if Bundles('mattn/emmet-vim')
  let g:user_emmet_mode='i' " only enabled in insert mode
  let g:user_emmet_leader_key = '<M-g>e' " mnemonic of 'expand'
  " let g:user_emmet_install_global = 0 " enabled only for certain file types
  " autocmd bundle FileType html,css EmmetInstall
endif

" Markdown runtime files
if Bundles('tpope/vim-markdown', '-nelstrom/vim-markdown-folding')
  let g:markdown_folding = 1
endif

" Preview various markup files with external tools
if s:ruby && Bundles('greyblake/vim-preview', '-matthias-guenther/hammer.vim')
  autocmd VimEnter * nunmap <Leader>P
endif
autocmd bundle VimEnter * command! -range=% PreviewMarkdown
      \ call markdown#preview(<line1>, <line2>)

" Javascript {{{2

" Vastly improved Javascript indentation and syntax support
call Bundles('pangloss/vim-javascript')

" A plugin that integrates JSHint with Vim
" call Bundles('walm/jshint.vim')

" Tern plugin for vim(provides Tern-based JavaScript editing support)
" call Bundles('marijnh/tern_for_vim')

" CoffeeScript support for vim
call Bundles('kchmck/vim-coffee-script')

" C Family {{{2

if Bundles('rust-lang/rust.vim')
  let g:rust_fold = 1 " folds are defined but opened
  " let g:rust_conceal = 1
  autocmd bundle FileType rust nnoremap <buffer>RR :RustRun<CR>|
        \nnoremap <buffer>R<Space> :RustRun
endif

" Golang {{{2

if Bundles('fatih/vim-go', 'garyburd/go-explorer')
  let g:go_auto_type_info = 0
  let g:go_fmt_autosave = 0
  let g:go_dispatch_enabled = 0

  autocmd bundle FileType godoc nnoremap <buffer> q <C-W>q
  autocmd bundle FileType gedoc nnoremap <buffer> q <C-W>q

  let g:go_bin_path = has('win32unix') ?
        \ '/cygdrive/'.tolower($GOPATH[0]).
        \   substitute($GOPATH[2:], '\\', '/', 'g').'/bin/' :
        \ expand("$GOPATH/bin/")
  let g:go_disable_autoinstall = 1 " run in another instance to be asynchronous

  " call add(g:syntastic_mode_map['passive_filetypes'], 'go')
endif

" Ruby {{{2

" Ruby runtime files (shipped with Vim and fairly updated.)
if Bundles('Vim-ruby/vim-ruby')
endif

" A custom text object for selecting ruby blocks
if Bundle('Nelstrom/vim-textobj-rubyblock', {'f':'ruby'})
elseif Bundles('rhysd/vim-textobj-ruby') " provide more controls over the above
  let g:textobj_ruby_more_mappings = 1
endif

" Runs RuboCop(A robust Ruby code analyzer) and displays the results in Vim
if Bundles('ngmy/vim-rubocop')
  let g:vimrubocop_keymap = 0
  autocmd bundle FileType ruby nnoremap <silent> <buffer> <nowait>
        \ <LocalLeader>r :RuboCop<CR>
endif

" Bindings for the gem recording the results of every line of code
if Bundles('hwartig/vim-seeing-is-believing')
  autocmd bundle FileType ruby
        \ NXInoremap <buffer> <F5> <Plug>(seeing-is-believing-run)|
        \ NXInoremap <buffer> <F4> <Plug>(seeing-is-believing-mark)
endif

" Vim plugin for debugging Ruby applications (using ruby-debug-ide gem)
" call Bundles('astashov/vim-ruby-debugger')

" It's like rails.vim without the rails
call Bundle('tpope/vim-rake', {'f':'ruby'})

" Python {{{2

" Vim python-mode. PyLint, Rope, Pydoc, breakpoints from box.
" (Known to conflict with 'jedi-vim'.)
if 0 && Bundles('klen/python-mode')
  let g:pymode_run_bind = '<LocalLeader>r'
  let g:pymode_breakpoint_bind = '<LocalLeader>b'
  let g:pymode_rope = 0
  " Escape syntastic check for python
  call add(get(get(g:, 'syntastic_mode_map', {}), 'passive_filetypes', []), 'python')
  let g:pymode_python = 'python3'
  autocmd bundle VimEnter * set shellslash&
endif

" Bindings for the python auto-completion library 'jedi'
if s:pythonx && Bundles('davidhalter/jedi-vim')
  let g:jedi#goto_assignments_command = 'gd'
  let g:jedi#goto_command = 'gD'
  let g:jedi#rename_command = '<LocalLeader>r'
  let g:jedi#usages_command = '<LocalLeader>u'
  " let g:jedi#use_tabs_not_buffers = 1
  " let g:jedi#use_splits_not_buffers = 'winwidth'

  " Completion
  autocmd bundle FileType python setlocal completeopt=menuone,longest,preview
  let g:jedi#show_call_signatures = 2 " show it in the command line

  " let g:jedi#force_py_version = has('python3') ? 3 : 2
  nnoremap c\p :call jedi#force_py_version_switch()<CR>

  " Let g:jedi#auto_initialization = 0
  let g:jedi#auto_vim_configuration = 0
  let g:jedi#completions_command = '' " don't map for omni completion
endif

" A two-way integration between Vim and IPython 0.11+
call Bundles('-ivanov/vim-ipython')

" Java(JVM) {{{2

" Set 'path' from the Java class path
call Bundles('tpope/vim-classpath')

" My work on integration of Scala into Vim - not a ton here, but useful for me
" call Bundles('derekwyatt/vim-scala')

" Clojure {{{2

" Clojure runtime files (shipped with Vim versions 7.3.803+)
call Bundles('guns/vim-clojure-static')
" let g:clojure_fold = 1 " Fold list/vector/map that extends over multi-lines

" Clojure REPL tease
call Bundles('tpope/vim-fireplace')

" Static support for Leiningen
if !has('win32unix') && Bundles('tpope/vim-leiningen')
endif

" Precision Editing for S-expressions
if Bundles('guns/vim-sexp', 'tpope/vim-sexp-mappings-for-regular-people')
  let g:sexp_filetypes = '' " disable default local mapping
endif

" Extend builtin syntax highlighting to referred and aliased vars
" call Bundles('guns/vim-clojure-highlight',
"       \ 'guns/vim-clojure-static', 'tpope/vim-fireplace')

" Simpler Rainbow Parentheses
if Bundles('junegunn/rainbow_parentheses.vim')
  autocmd bundle FileType lisp,clojure,scheme RainbowParentheses
  " Toggle
  nnoremap <silent>c\r :RainbowParentheses!!<CR>
  " let g:rainbow#pairs = [['(', ')'], ['[', ']']]
  " List of colors that you do not want. ANSI code or #RRGGBB
  " let g:rainbow#blacklist = [233, 234]
  " let g:rainbow#max_level = 12
endif

" Others {{{2

" JSON runtime files
if Bundles('elzr/vim-json')
  autocmd bundle FileType json setlocal foldmethod=syntax
endif

" JSON manipulation and pretty printing
call Bundles('tpope/vim-jdaddy')
command! -range=% JSONFormat <line1>,<line2>!jq .
command! -range=% JSONFormatEncode <line1>,<line2>!python -m json.tool

" A Vim plugin for Windows PowerShell support
call Bundles('pprovost/vim-ps1')

" Syntax file for nginx
call Bundles('vim-scripts/nginx.vim')

" A mirror to the official vimperator's syntax file
call Bundles('bohrshaw/vim-vimperator-syntax')

" ExternalInteraction: {{{1

" Communicate with Nvim through FUSE(user space file system)
if 0 && s:nvim && Bundles('fmoralesc/nvimfs')
endif

" An asynchronous execution library
if Bundles('bohrshaw/vimproc.vim', '-shougo/vimproc.vim')
  command! -nargs=+ -bang -complete=shellcmd B
        \ if <bang>0 | call vimproc#system_bg(<SID>vimproc_esc(<q-args>)) |
        \ else | execute 'VimProcBang '.<SID>vimproc_esc(<q-args>, '/') | endif
  function! s:vimproc_esc(args, ...)
    if has('win32') && !&shellslash " expand %, #, etc. and escape \ and /
      let pat = '\\\@<![%#].*'
      let match = matchstr(a:args, pat)
      return escape(
            \ empty(match) ? a:args :
            \   substitute(a:args, pat, escape(expand(match), '\'), ''),
            \ '\'.get(a:, 1, ''))
    endif
    return a:args
  endfunction
  command! -nargs=+ -complete=shellcmd R VimProcRead <args>
endif

" Shells inside Vim
if has('nvim')
  " Manage multiple shells
  nnoremap <silent><M-s> :<C-u>call <SID>shell(v:count1)<CR>
  command! -nargs=? Shell call <SID>shell(<q-args>)
  command! -nargs=? S call <SID>shell(<q-args>)
  cabbrev <expr>sS getcmdtype() == ':' && getcmdpos() == 3 ? 'sb\|S' : 'sS'
  cabbrev <expr>vS getcmdtype() == ':' && getcmdpos() == 3 ? 'vert sb\|S' : 'vS'
  cabbrev <expr>tS getcmdtype() == ':' && getcmdpos() == 3 ? 'tab sb\|S' : 'tS'
  function! s:shell(name)
    let name = empty(a:name) ? '1' : a:name
    try
      execute 'buffer term://*;#;'.name
    catch
      enew|call termopen(matchstr(&shell,'\a*$').';#;'.name)|startinsert
    endtry
  endfunction
  tnoremap <M-C-d> <C-\><C-n>:bwipeout!<CR>
  nnoremap <Leader>bs :Unite -input=term:/\ zsh\|bash\  buffer<CR>
elseif Bundles('shougo/vimshell.vim', 'bohrshaw/vimproc.vim')
  nnoremap <M-s> :<C-U>VimShell<CR>
  let g:vimshell_split_command = 'split'
  let g:vimshell_prompt = '% '
  let g:vimshell_secondary_prompt = '> '
  let g:vimshell_user_prompt = 'fnamemodify(getcwd(), ":~")'
endif

" The interface to Web API
if Bundles('mattn/webapi-vim')
  let g:webapi#system_function = has('win32') ?
        \ 'vimproc#cmd#system' : 'vimproc#system'
endif

" A Git wrapper so awesome, it should be illegal.
if Bundles('Tpope/vim-git') && BundleRun('tpope/vim-fugitive')
  " Git deserves a convenient leader key for mappings
  nnoremap g<Space>s :Gstatus<CR>

  nnoremap g<Space>c<Space> :Gcommit -v<CR>
  nnoremap g<Space>ca       :Gcommit --amend -v<CR>

  " Add the current file and commit
  nnoremap <silent>g<Space>a<Space> :call <SID>git_add_current()<CR>
  nmap     g<Space>ac               g<Space>a<Space>:Gcommit -v<CR>
  nmap     g<Space>aa               g<Space>a<Space>:Gcommit --amend -v<CR>
  " Add all files and commit
  nnoremap g<Space>A<Space> :wall \| G! add --update<CR>
  nnoremap g<Space>AA       :wall \| G! add --all<CR>
  nnoremap g<Space>Ac       :wall \| Gcommit --all -v<CR>
  nnoremap g<Space>Aa       :wall \| Gcommit --all --amend -v<CR>
  " Routine commits
  nnoremap g<Space>r<Space> :G! commit --allow-empty-message -m ''<CR>
  nmap     g<Space>ra       g<Space>a<Space>:G! commit --allow-empty-message -m ''<CR>
  nnoremap g<Space>rA       :wall \| G! commit --all --allow-empty-message -m ''<CR>
  nmap     g<Space>rt       g<Space>a<Space>:G! commit -m 'Todo'<CR>
  nmap     g<Space>rd       g<Space>a<Space>:G! commit -m 'Done'<CR>
  nnoremap <expr>g<Space>rs ':B! git --git-dir='.expand('~/.vim/spell/.git').
        \ ' --work-tree='.expand('~/.vim/spell')." commit --all -m 'Spell'<CR>"

  nnoremap g<Space>d :tab sbuffer % \| Gdiff<CR>
  nnoremap g<Space>b :Gblame<CR>
  nnoremap g<Space>l :Glog<CR>

  nnoremap g<Space>ps :G! push<CR>
  nnoremap g<Space>pf :G! push -f<CR>
  nnoremap g<Space>pl :G! pull<CR>

  nnoremap <expr><M-f>/ ':cd '.b:git_dir[:-6]."<CR>"
  nnoremap <expr><M-f>\ ':lcd '.b:git_dir[:-6]."<CR>"

  function! s:git_add_current()
    update
    call fugitive#repo().git_chomp_in_tree('add', expand('%:p')[len(b:git_dir)-4:])
  endfunction

  " A command :G using vimproc, an alternative to :Git
  execute "command! -nargs=1 -bang "
        \ "-complete=customlist,<SNR>".scriptease#scriptid(globpath(&rtp, 'plugin/fugitive.vim'))."_GitComplete"
        \ "G execute 'B'.(<bang>0 ? '!' : '') 'git' (exists('b:git_dir') ? '--git-dir='.b:git_dir.' --work-tree='.b:git_dir[:-6] : '') <q-args>"

  autocmd bundle FileType gitcommit set foldmethod=syntax foldlevel=1
  autocmd bundle FileType git set foldlevel=1

  " Git branch management
  " call Bundles('sodapopcan/vim-twiggy')

  " A git repository viewer(a gitk clone)
  call Bundle('gregsexton/gitv', {'c': 'Gitv'})
endif

" Shows a git diff in the sign column and stages/reverts hunks
if Bundles('airblade/vim-gitgutter')
  " let g:gitgutter_enabled = 0
  " let g:gitgutter_signs = 0
  let g:gitgutter_realtime = 0
  let g:gitgutter_eager = 0
  " let g:gitgutter_diff_args = '-w'
  " let g:gitgutter_highlight_lines = 1
  let g:gitgutter_sign_removed = '-'
  let g:gitgutter_sign_modified_removed = '='
  let g:gitgutter_map_keys = 0
  nnoremap g<Space>ds :call gitgutter#toggle()<CR>
  nnoremap g<Space>u :GitGutter<CR>
  nnoremap g<Space>U :GitGutterAll<CR>
  nmap [c <Plug>GitGutterPrevHunk
  nmap ]c <Plug>GitGutterNextHunk
  nmap <silent> dp :execute &diff ? 'diffput' : 'GitGutterStageHunk'<CR>
  nmap <silent> do :execute &diff ? 'diffget' : 'GitGutterRevertHunk'<CR>
  nmap dP :GitGutterPreviewHunk<CR>
endif

" Show a VCS diff using Vim's sign column
if Bundles('-mhinz/vim-signify')
  " let g:signify_disable_by_default = 1
  let g:signify_vcs_list = ['git']
  let g:signify_sign_delete = '-'
endif

" Browse GitHub events
if Bundles('junegunn/vim-github-dashboard')
  let g:github_dashboard = {'username': 'bohrshaw'}
  nnoremap g<Space>hd :GHDashboard!<CR>
  nnoremap g<Space>ha :GHActivity!<CR>
endif

" Helpers for UNIX(Windows)
if Bundles('tpope/vim-eunuch')
  nnoremap <silent><M-f>d :Remove<CR>
  nnoremap <silent><M-f>x :sbuffer #<Bar>wincmd p<Bar>Remove<CR>
  autocmd VimEnter * command! -bar W if has('nvim') |
        \ execute "silent !sudo -vn &>/dev/null" |
        \ if v:shell_error != 0 |
        \ execute "silent !sudo -vS <<<'".inputsecret('[sudo] password: ')."'" |
        \ endif |
        \ SudoWrite | endif
  nnoremap <silent><M-f>W :W<CR>
endif

" Tmux basics, insert mode completion of words in adjacent tmux panes
if !has('win32') && Bundles('tpope/vim-tbone', 'wellle/tmux-complete.vim')
  let g:tmuxcomplete#trigger = '' " completefunc, omnifunc, or empty
endif

" Transparent editing of GPG encrypted files
if Bundle('Jamessan/vim-gnupg', {'f': '*.{gpg,asc,pgp}'})
  " For maximum privacy, I'd better edit in a standalone Vim instance with
  " minimum number of bundles.
  command! -nargs=? -complete=command GPG
        \ B! gvim --cmd 'let l=1' -c 'BundleRun vim-gnupg' -c '<args>'
  " If I would be careful enough or am not concerned with the encrypted file,
  " it's fine to edit within the current Vim instance. But ensure 'viminfo' is
  " restored afterwards. 'viminfo' stores info in the whole session even is it's
  " reset for some time.
  if !g:l
    autocmd bundle BufDelete *.{gpg,asc,pgp} let &viminfo = _viminfo
  endif
  let g:GPGDefaultRecipients = ['Bohr Shaw']

  " For writing encrypted diaries
  command! -nargs=? -complete=file Diary
        \ if !exists("g:loaded_gnupg") |BundleRun vim-gnupg |endif |
        \ edit `=fnamemodify(get(g:, 'DIARY_PATH', ''), ':p').
        \   (empty(<q-args>) ? strftime('%Y%m%d') : <q-args>).'.gpg'`
  autocmd bundle BufNewFile,BufReadPost */diar{y,ies}/*.{gpg,asc,pgp}
        \ setlocal nolinebreak spell spelllang=en,cjk
endif

" Translation
if Bundles('bohrshaw/vim-trance', 'mattn/webapi-vim')
  " let g:trance#default = 'iciba'
  " Translation services
  let g:trance = {
        \ 'youdao': 'key=1387543717&keyfrom=vim-translate',
        \ 'baidu': 'client_id=OjbuMOjZUwHtxcnxblAoQzds',
        \ }
  " let g:trance#youdao_target = 'dict' " 'translate', 'dict' or ''(both)
  " let g:trance#truncate = 0 " truncate long output to be unobtrusive
  NXmap t<CR> <Plug>trance
endif

" URL shortener
call Bundles('bohrshaw/vim-url-shortener')

" Open a URI with the default browser
" Another way is `:py import webbrowser; webbrowser.open()`
if Bundles('tyru/open-browser.vim')
  NXmap gx <Plug>(openbrowser-smart-search)
  " This will merge into the default one
  let g:openbrowser_search_engines = {
        \ 'google_hk': 'https://google.com.hk/search?q={query}',
        \ 'bing': 'http://global.bing.com/search?q={query}&setmkt=en-us&setlang=en-us',
        \ 'baidu': 'http://www.baidu.com/s?wd={query}',
        \ 'haosou': 'http://www.haosou.com/s?q={query}',
        \ 'translate': 'https://translate.google.com.hk/#auto/zh-CN/{query}',
        \ 'stackoverflow': 'https://stackoverflow.com/search?q={query}',
        \ }
  let g:openbrowser_default_search = 'bing'
  let g:netrw_nogx = 1 " disable netrw's gx mapping
  " Remove unused commands
  autocmd bundle VimEnter * delcommand OpenBrowser | delcommand OpenBrowserSearch
endif
command! -nargs=1 Google call function(
      \exists('*netrw#NetrwBrowseX')?'netrw#NetrwBrowseX':'netrw#BrowseX')(
      \"https://www.google.com/search?q=".expand("<args>"),0)

" Vimscript for gist
if Bundles('mattn/gist-vim', 'mattn/webapi-vim')
  let g:gist_post_private = 1
endif

" Run code on codepad.org
if Bundles('mattn/codepad-vim', 'mattn/webapi-vim')
  NXnoremap <Leader>R :CodePadRun<CR>
endif

" Interact with the simplenote service
" call Bundles('mrtazz/simplenote.vim')

" Browse Hacker News inside Vim, :pip install hackernews-python
if Dundles('ryanss/vim-hackernews')
  command! HackerNews call BundleRun('vim-hackernews') |HackerNews
endif

" AlternativeUsages: {{{1

" Personal Wiki for Vim
if Bundles('-vimwiki/vimwiki')
  " Restrict vimwiki's operation to only those paths listed in g:vimwiki_list.
  let g:vimwiki_global_ext = 0
  " Don't conceal characters
  let g:vimwiki_conceallevel = 0
  " Register one or more wikis
  let g:vimwiki_list = [{'path': '~/vimwiki/',
        \ 'syntax': 'markdown',
        \ 'ext': '.md'}]
endif

" A calendar application
if Bundles('itchyny/calendar.vim')
  " let g:calendar_google_calendar = 1
  " let g:calendar_google_task = 1
endif

" A convenient interactive calculator inside a buffer
call Bundle('gregsexton/vimcalc', {'c': 'Calc'})

" Task managers
" call Bundles('aaronbieber/quicktask', 'davidoc/taskpaper.vim',
"       \ 'davidoc/todo.txt-vim')

" vim:foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ \\a\\+\:\ {'?'>1'\:getline(v\:lnum)=~'^\"\ \\a\\+\ {'?'>2'\:getline(v\:lnum)=~#'\\v^(\ \ )\?(if|fu)'?'a1'\:getline(v\:lnum)=~#'\\v^(\ \ )\?end'?'s1'\:'=':
