" This is a vimrc file providing the core configuration for vim.
" Do only corrections, customisation should be made other where.

" Changeless {{{

" Options {{{
set nocompatible
filetype plugin indent on " Must be after pathogen or vundle setup
syntax on

set ruler " Show the cursor position
set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%)

set showmode " Display the current mode

" Show non-normal spaces, tabs etc
set list
" Candidates are tab:,.,trail:.,nbsp:%,eol:Â¬
set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
if !has('win32') && (&termencoding ==# 'utf-8' || &encoding ==# 'utf-8')
  let &listchars = "tab:\u21e5 ,trail:\u2423,extends:\u21c9,precedes:\u21c7,nbsp:\u00b7"
endif

set winminheight=0 " Windows can be 0 line high

set background=dark " Assume a dark background for colorschemes

set showmatch " Show matching brackets/parenthesis

" Exclude options and mappings in saved sessions and views
set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize,slash,unix
set viewoptions=folds,cursor,unix,slash

" Acceptable encryption strength, also remember to set viminfo=
" Swap and undo are all encrypted, but may set nowritebackup and nobackup(default)
set cryptmethod=blowfish

" Avoid all the hit-enter prompts caused by file messages
set shortmess+=filmnrwxoOtTI

" Allow color schemes do bright colors without forcing bold.
if &t_Co == 8 && $TERM !~# '^linux'
  set t_Co=16
endif

if &term == 'xterm' || &term == 'xterm-256color' || &term == 'screen'
  " Enable 256 colors to stop the CSApprox warning
  set t_Co=256
  let g:solarized_termcolors=256
endif

set visualbell t_vb= " No beep or flash
" Disable error sounds and error screen flash
au GUIEnter * set vb t_vb=

" Backspace through anything in insert mode
set backspace=indent,eol,start

set showcmd " Show partial commands in status line and

set autoread " Automatically read a file that has changed on disk

set wildmenu " Show list instead of just completing
" Command <Tab> completion, list matches, then longest common part, then all.
set wildmode=list:longest,full
set wildignorecase " Ignore case in command line auto-completion

set tabpagemax=50 " Allow more tabs

set display+=lastline " Ensure the last line is properly displayed

set scrolloff=1 " Minimum lines to keep above and below cursor
set sidescrolloff=5 " The minimal number of screen columns to keep around the cursor

set incsearch " Find as you type search
set ignorecase " Case insensitive search
set smartcase " Case sensitive when uc present

" Use multiple of shiftwidth to round when indenting with '<' and '>'
set shiftround
" Indent at the same level of the previous line
set autoindent
set expandtab " Expand a tab to spaces
set smarttab " Make tab width equals shiftwidth

" Timeout on key codes
set ttimeout
" Key code delay (can avoid the delay in entering normal mode after pressing ESC)
set ttimeoutlen=50

" Don't assume numbers start with zero are octal, affecting CTRL-A and CTRL-X
set nrformats-=octal

" Don't scan included files for keyword completion.
set complete-=i

" Avoid the problem occurred when you write to symbolic files on windows
set nowritebackup

" Extended matching with '%'
runtime macros/matchit.vim
" }}}

" Mappings {{{

" Life changing {{{
" One key instead of two
nnoremap ; :
xnoremap ; :
" I won't move backwards
nnoremap , ;
xnoremap , ;
" Two keys instead of three
nnoremap z; q:
" Three keys instead of four
nnoremap @; @:
" }}}

" Two maps enough for switching between windows
noremap <C-J> <C-W>w
noremap <C-K> <C-W>W

" Move a tab
nnoremap <silent> <A-Left> :execute 'silent! tabmove ' . (tabpagenr()-2)<CR>
nnoremap <silent> <A-Right> :execute 'silent! tabmove ' . tabpagenr()<CR>

" Be consistent with other operators
nnoremap Y y$

" Break undo sequence
inoremap <c-u> <c-g>u<c-u>

" Make repeating last substitution keep the flags
nnoremap & :&&<cr>
xnoremap & :&&<cr>

" Toggle fold
nnoremap <space> za
xnoremap <space> za

cnoremap vsb vert sb 

" Wrapped lines goes down/up to next row, rather than next line in file.
nnoremap j gj
nnoremap gj j
nnoremap k gk
nnoremap gk k

" Visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv

" Easier horizontal scrolling
noremap zl zL
noremap zh zH

" Familiar command line editing shortcuts
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <c-f> <Right>
cnoremap <c-b> <Left>
cnoremap <c-d> <Del>
set cedit=<c-g>
" }}}

" }}}

" Changeable {{{

" Options {{{

" Set default path of temporary files {{{
function! SetPath()
  let dir_list = { 'swap': 'directory', 'undo': 'undodir', 'backup': 'backupdir' }
  for [dir_name, set_name] in items(dir_list)
    let set_value = $HOME . '/.vim/tmp/' . dir_name . "/"
    if !isdirectory(set_value) | silent! call mkdir(set_value) | endif
    exec "set " . set_name . "^=" . set_value . "/"
  endfor
  set viewdir=~/.vim/tmp/view
  set viminfo=!,'50,<50,s10,h,n$HOME/.vim/tmp/viminfo
endfunction
call SetPath()
" }}}

" Look for(gf) files in the same directory as the editing file,
" the current working directory, and the home directory.
set path=.,,~

set cdpath=,,~/projects

set fileformats=unix,dos " Affect new files
set fileformat=unix " Local to buffer
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,latin1
set encoding=utf-8 "Sets the character encoding used inside Vim

" Number of spaces to use for each step of (auto)indent
set shiftwidth=2
" Number of spaces a tab displayed in
set tabstop=2
" Number of spaces used when press <Tab> or <BS>
set softtabstop=2

" Lines to scroll when cursor leaves screen
" set scrolljump=2

" Link unnamed register and OS clipboard:
" set clipboard=unnamed

set hidden " Maybe set autowrite

set mouse=a " Enable mouse in all modes

set spell " Check spell

" Save undo history to disk when write a buffer
set undofile

" set matchpairs+=<:> " For %

" set number " Line numbers on
" set relativenumber

" Don't redraw the screen while executing macros etc.
set nolazyredraw

" Wrap lines at a character in 'breakat', used to not break a word
" set linebreak
" }}}

" Mappings and commands {{{
inoremap jk <Esc>

cmap w!! w !sudo tee % >/dev/null

" Some helpers to edit mode, see: http://vimcasts.org/e/14
cnoremap %% <C-R>=expand('%:h').'/'<cr>
nmap <leader>ew :e %%
nmap <leader>es :sp %%
nmap <leader>ev :vsp %%
nmap <leader>et :tabe %%
" }}}

" Statusline {{{
set laststatus=2 " Always display statusline

" '%1' is to switch to User1 highlight
" '%*' is to switch back to statusline highlight 
" E.g.: set statusline=%1*%f%*

" File modified flag, preview flag, quickfix flag, help flag
set statusline=%m%w%q%h

" File name(truncate if too long) and current working directory
set statusline+=%<%t(%{split(getcwd(),'/')[-1]}

" Custom git branch status
function! Git_branch_status()
  if exists('*fugitive#head')
    let status = fugitive#head(7)
    return status != '' ? ','.status : ''
  endif
  return ''
endfunction
set statusline+=%{Git_branch_status()})

" File modification time
" set statusline+=\ %{strftime(\"%H:%M\",getftime(expand(\"%:p\")))}

" File format
set statusline+=,%{&ff}
" File encoding
set statusline+=%{strlen(&fenc)?','.&fenc:''}
" File type
set statusline+=%{strlen(&ft)?','.&ft:''}

" Software caps lock status
set statusline+=\ %{exists('*CapsLockSTATUSLINE')?CapsLockSTATUSLINE():''}

" Left/Right separator
set statusline+=%=

" Position and percentage
set statusline+=%l/%L,%p%%
" set statusline+=%-1.(%l/%L%)\ %p%%

" Change status line color after vim started, thus prevent color schemes modify the color
autocmd VimEnter * hi statusline ctermbg=Gray ctermfg=black guibg=black guifg=DarkCyan

" Reapply the status line color after switching a color scheme
" Note: In gui, fg is actually background light blue, and bg is actually font color
autocmd ColorScheme * hi statusline ctermbg=Gray ctermfg=black guibg=black guifg=DarkCyan
" }}}

" Differences between GUI and terminal {{{
if has('gui_running')
  if has('win32') || has('win64')
      set guifont=Consolas:h10
      au GUIEnter * simalt ~x " max window
  else
      " set guifont=Consolas\ 10
      set lines=250 columns=200
  endif

  set guioptions=

  " Change the default working directory to HOME
  if 0 == argc() | cd $HOME | endif
endif
" }}}

" }}}

" vim:ft=vim tw=80 et sw=2 fdm=marker cms="\ %s nowrap:

