" This file contains bundles to bundle and bundles configuration.
" Be careful not to add comments directly after a bundle statement.
" vim: nowrap fdm=marker
    " Deps {{{1
        Bundle 'MarcWeber/vim-addon-mw-utils'
        Bundle 'tomtom/tlib_vim'
    "}}}

    " list only the plugin groups you will use
    let g:bundle_groups=['general', 'neocomplcache', 'programming', 'misc']

    " general {{{1
        if count(g:bundle_groups, 'general')
            " file, buffer and undo manager {{{2
            Bundle 'scrooloose/nerdtree'
                noremap <C-n> :NERDTreeToggle<CR>:NERDTreeMirror<CR>
                nmap <leader>n :NERDTreeFind<CR>
                let NERDTreeShowBookmarks=1
                let NERDTreeIgnore=['\.pyc', '\~$', '\.swo$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr']
                let NERDTreeChDirMode=0
                let NERDTreeQuitOnOpen=1
                let NERDTreeMouseMode=2
                let NERDTreeShowHidden=1
                let NERDTreeKeepTreeInNewTab=1
                let g:nerdtree_tabs_open_on_gui_startup=0
                let g:NERDShutUp=1
            Bundle 'jistr/vim-nerdtree-tabs'
                "nmap <leader>n <plug>NERDTreeTabsToggle<CR>
            Bundle 'kien/ctrlp.vim'
                let g:ctrlp_working_path_mode = 2
                nnoremap <silent> <D-t> :CtrlP<CR>
                nnoremap <silent> <D-r> :CtrlPMRU<CR>
                let g:ctrlp_custom_ignore = {
                    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
                    \ 'file': '\.exe$\|\.so$\|\.dll$' }

            " Bundle 'corntrace/bufexplorer'
            Bundle 'jeetsukumaran/vim-buffergator'

            "pure viml
            Bundle 'mbbill/undotree'
                nnoremap <F5> :UndotreeToggle<CR>
                let g:undotree_SetFocusWhenToggle=1 " put cursor to undotree when togglling
            "need python support
            " Bundle 'sjl/gundo.vim'
            "     nnoremap <F5> :GundoToggle<CR>
            "}}}

            Bundle 'Lokaltog/vim-easymotion'

            Bundle 'tpope/vim-surround'
            Bundle 'tpope/vim-abolish'
            Bundle 'tpope/vim-unimpaired'
            Bundle 'tpope/vim-commentary'
            Bundle 'tpope/vim-speeddating'
            Bundle 'tpope/vim-repeat'
                "Adding support to a plugin is generally as simple as the following command at the end of your map functions.
                "silent! call repeat#set("\<Plug>MyWonderfulMap", v:count)
            if has("unix")
                Bundle 'tpope/vim-eunuch'
            endif

            Bundle 'myusuf3/numbers.vim'
            Bundle 'Raimondi/delimitMate'
            Bundle 'matchit.zip'
            " Bundle 'vim-scripts/sessionman.vim'
            "     nnoremap <leader>sl :SessionList<CR>
            "     nnoremap <leader>ss :SessionSave<CR>
            "Bundle 'restore_view.vim'
            Bundle 'nathanaelkane/vim-indent-guides'
                let g:indent_guides_auto_colors = 1
                let g:indent_guides_start_level = 2
                let g:indent_guides_guide_size = 1
                let g:indent_guides_enable_on_vim_startup = 1
            "Bundle 'Lokaltog/vim-powerline'
            " about 3000 line
            " Bundle 'YankRing.vim'
            Bundle 'vimwiki'

            Bundle 'altercation/vim-colors-solarized'
            Bundle 'spf13/vim-colors'
            "Bundle 'flazz/vim-colorschemes'
            if !has('gui_running')
                Bundle 'godlygeek/csapprox'
            endif
        endif

    " programming {{{1
        if count(g:bundle_groups, 'programming')
            " Pick one of the checksyntax, jslint, or syntastic
            Bundle 'scrooloose/syntastic'
            Bundle 'tpope/vim-fugitive'
                nnoremap <silent> <leader>gs :Gstatus<CR>
                nnoremap <silent> <leader>gd :Gdiff<CR>
                nnoremap <silent> <leader>gc :Gcommit<CR>
                nnoremap <silent> <leader>gb :Gblame<CR>
                nnoremap <silent> <leader>gl :Glog<CR>
                nnoremap <silent> <leader>gp :Git push<CR>
            "Bundle 'scrooloose/nerdcommenter'
            Bundle 'godlygeek/tabular'
                nmap <Leader>a= :Tabularize /=<CR>
                vmap <Leader>a= :Tabularize /=<CR>
                nmap <Leader>a: :Tabularize /:<CR>
                vmap <Leader>a: :Tabularize /:<CR>
                nmap <Leader>a:: :Tabularize /:\zs<CR>
                vmap <Leader>a:: :Tabularize /:\zs<CR>
                nmap <Leader>a, :Tabularize /,<CR>
                vmap <Leader>a, :Tabularize /,<CR>
                nmap <Leader>a<Bar> :Tabularize /<Bar><CR>
                vmap <Leader>a<Bar> :Tabularize /<Bar><CR>
            Bundle 'mattn/webapi-vim'
            Bundle 'mattn/gist-vim'
            if executable('ctags')
                Bundle 'majutsushi/tagbar'
                    set tags=./tags;/,~/.vimtags
                    nnoremap <silent> <leader>tt :TagbarToggle<CR>
            endif
        endif

    " snipmate & neocomplcache {{{1
        if count(g:bundle_groups, 'snipmate')
            Bundle 'garbas/vim-snipmate'
            Bundle 'honza/snipmate-snippets'
            " Source support_function.vim to support snipmate-snippets.
            if filereadable(expand("~/.vim/bundle/snipmate-snippets/snippets/support_functions.vim"))
                source ~/.vim/bundle/snipmate-snippets/snippets/support_functions.vim
            endif
        elseif count(g:bundle_groups, 'neocomplcache')
            Bundle 'Shougo/neocomplcache'
                let g:acp_enableAtStartup = 0
                let g:neocomplcache_enable_at_startup = 1
                let g:neocomplcache_enable_smart_case = 1
                let g:neocomplcache_min_syntax_length = 3
                let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

                " Define dictionary.
                let g:neocomplcache_dictionary_filetype_lists = {
                            \ 'default' : '',
                            \ 'vimshell' : $HOME.'/.vimshell_hist',
                            \ 'scheme' : $HOME.'/.gosh_completions'
                            \ }

                " Define keyword.
                if !exists('g:neocomplcache_keyword_patterns')
                    let g:neocomplcache_keyword_patterns = {}
                endif
                let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

                " Plugin key-mappings.
                inoremap <expr><C-g> neocomplcache#undo_completion()
                inoremap <expr><C-l> neocomplcache#complete_common_string()

                " Recommended key-mappings.
                " <CR>: close popup and save indent.
                inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
                function! s:my_cr_function()
                    return neocomplcache#smart_close_popup() . "\<CR>"
                    " For no inserting <CR> key.
                    "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
                endfunction
                " <TAB>: completion.
                inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
                " <C-h>, <BS>: close popup and delete backword char.
                inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
                inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
                inoremap <expr><C-y> neocomplcache#close_popup()
                inoremap <expr><C-e> neocomplcache#cancel_popup()

                " Enable omni completion.
                autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
                autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
                autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
                autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
                autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
                autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete

                " Enable heavy omni completion.
                if !exists('g:neocomplcache_omni_patterns')
                    let g:neocomplcache_omni_patterns = {}
                endif
                let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
                let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
                let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
                let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
            Bundle 'Shougo/neosnippet'
                " use honza's snippets
                let g:neosnippet#snippets_directory='~/.vim/bundle/snipmate-snippets/snippets'

                " Plugin key-mappings.
                imap <C-k> <Plug>(neosnippet_expand_or_jump)
                smap <C-k> <Plug>(neosnippet_expand_or_jump)
                xmap <C-k> <Plug>(neosnippet_expand_target)
                xmap <C-l> <Plug>(neosnippet_start_unite_snippet_target)

                " SuperTab like snippets behavior.
                imap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
                smap <expr><TAB> neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

                " For snippet_complete marker.
                if has('conceal')
                    set conceallevel=2 concealcursor=i
                endif
            Bundle 'honza/snipmate-snippets'
        endif

    " php {{{1
        if count(g:bundle_groups, 'php')
            Bundle 'spf13/PIV'
                let g:DisableAutoPHPFolding = 0
                let g:PIVAutoClose = 0
            Bundle 'beyondwords/vim-twig'
        endif

    " scala {{{1
        if count(g:bundle_groups, 'scala')
            Bundle 'derekwyatt/vim-scala'
            Bundle 'derekwyatt/vim-sbt'
        endif

    " python {{{1
        if count(g:bundle_groups, 'python')
            " Pick either python-mode or pyflakes & pydoc
            Bundle 'klen/python-mode'
                if !has('python')
                   let g:pymode = 1
                endif
                let g:pymode_lint_checker = "pyflakes"
            Bundle 'python.vim'
            Bundle 'python_match.vim'
            Bundle 'pythoncomplete'
        endif

    " ruby {{{1
        if count(g:bundle_groups, 'ruby')
            "Bundle 'tpope/vim-rails'
            "Bundle 'tpope/vim-cucumber'
            "Bundle 'quentindecock/vim-cucumber-align-pipes'
            let g:rubycomplete_buffer_loading = 1
            "let g:rubycomplete_classes_in_global = 1
            "let g:rubycomplete_rails = 1
        endif

    " javascript {{{1
        if count(g:bundle_groups, 'javascript')
            Bundle 'leshill/vim-json'
            Bundle 'groenewege/vim-less'
            Bundle 'pangloss/vim-javascript'
            Bundle 'briancollins/vim-jst'
        endif

    " html {{{1
        if count(g:bundle_groups, 'html')
            Bundle 'amirh/HTML-AutoCloseTag'
            Bundle 'hail2u/vim-css3-syntax'
            " A parser for a condensed HTML format
            Bundle 'rstacruz/sparkup'
        endif

    " misc {{{1
        if count(g:bundle_groups, 'misc')
            Bundle 'tpope/vim-markdown'
            Bundle 'spf13/vim-preview'
            Bundle 'Puppet-Syntax-Highlighting'
        endif
