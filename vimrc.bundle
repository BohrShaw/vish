" Description: Vim bundle configuration.
" Author: Bohr Shaw <pubohr@gmail.com>

" To keep Vim healthy, stable, efficient and consistent, I should choose bundles
" carefully and do customisation properly.
"
" Regarding to performance, in additiont to startup profiling, be aware of
" possible autocmd pollution which should actually be more concerned.

" BundleManagement: {{{1

call bundle#init() " bundle initialization

" Define an autocmd group and clean it
augroup bundle
  autocmd!
augroup END

" Mappings for managing bundles
autocmd bundle BufReadPost {.,}vimrc.bundle call s:bundle_map()
function! s:bundle_map()
  " Move between bundles
  nnoremap <buffer> <silent> ]g :call search('[BD]undle\a*(.\zs\C')<CR>
  nnoremap <buffer> <silent> [g :call search('[BD]undle\a*(.\zs\C', 'b')<CR>
  " Open a bundle's URL in the browser
  nnoremap <buffer> <silent> gX "zya'
        \:execute 'silent OpenBrowserSmartSearch https://github.com/'
        \.matchstr(@z, '\v''-?\zs[^'']*')<CR>
  " Activate the bundle under the cursor line
  nnoremap <buffer><silent> <LocalLeader>b mz"zyi'
        \:call BundleActivate(split(@z, '/')[1])<CR>g`z
endfunction

" A Vim plugin for Vim plugins
call Bundles('tpope/vim-scriptease')

" MotionSearch: {{{1

" The missing motion for Vim
if Bundles('-Justinmk/vim-sneak', 'Bohrshaw/vim-sneak')
  " let g:sneak#streak = 1 " enable streak mode
  " let g:sneak#streak_esc = "\<CR>" " key to exit streak-mode
  " let g:sneak#use_ic_scs = 1 " ignorecase and smartcase
  let sneak#textobject_z = 0 " prevent the default {operator}z mapping
  " Disable default mappings
  NXOmap <Plug>_Sneak_s <Plug>Sneak_s
  NXOmap <Plug>_Sneak_S <Plug>Sneak_S
  " TODO: more precise fFtT motions
  " Mapped fFtT could be slow or buggy in macros, and they conflict with Chinese IME
  " NXOmap f<CR> <Plug>Sneak_f
  " NXOmap F<CR> <Plug>Sneak_F
  " NXOmap t<CR> <Plug>Sneak_t
  " NXOmap T<CR> <Plug>Sneak_T
  " Arbitrary precise motion
  nnoremap <silent> L :call Sneak('', 0, 'n')<CR>
  xnoremap <silent> L :call Sneak('', 0, 'v')<CR>
  onoremap <silent> L :call Sneak('', 0, 'o')<CR>
  nnoremap <silent> H :call Sneak('', 1, 'n')<CR>
  xnoremap <silent> H :call Sneak('', 1, 'v')<CR>
  onoremap <silent> H :call Sneak('', 1, 'o')<CR>
  function! Sneak(pattern, reverse, mode)
    let c = v#getchar()
    if empty(c) |return |endif
    if a:mode =~# "^[vV\<C-v>]" |execute 'normal! gv' |endif
    if empty(a:pattern)
      if c =~# '\v^(\d|\a)$' " excluding positions surrounded with similar characters
        let p = c =~# '\d' ? '\d' : (c =~# '\l' ? '\l' : '\u')
        let pattern = '\v'.p.'@<!'.c.'|'.c.p.'@!'
      elseif c == "\<CR>" " last non-blank character of the line
        let pattern = '\S\s*\_$'
      elseif c == "\<BS>" " first non-blank character of the line
        let pattern = '\_^\s*\zs'
      else " literal
        let c = escape(c, '\')
        let pattern = '\V'.c.'\@<!'.c.'\|'.c.c.'\@!'
      endif
    else
      let pattern = substitute(a:pattern, '\CIN', c, 'g')
    endif
    " op, input, inputlen, count, repeatmotion, reverse, inclusive, streak
    call sneak#to('', '\m'.pattern, 1, 1, 0, a:reverse, 2, 2)
  endfunction
  " Mimic the native search command / and ?, but literal
  " Function signature: sneak#wrap(op, inputlen, reverse, inclusive, streak)
  nnoremap <silent> g/ :<C-U>call sneak#wrap('', 99, 0, 2, 1)<CR>
  nnoremap <silent> g? :<C-U>call sneak#wrap('', 99, 1, 2, 1)<CR>
  xnoremap <silent> g/ :<C-U>call sneak#wrap(visualmode(), 99, 0, 2, 1)<CR>
  xnoremap <silent> g? :<C-U>call sneak#wrap(visualmode(), 99, 1, 2, 1)<CR>
  onoremap <silent> g/ :<C-U>call sneak#wrap(v:operator, 99, 0, 2, 1)<CR>
  onoremap <silent> g? :<C-U>call sneak#wrap(v:operator, 99, 1, 2, 1)<CR>
  hi! link SneakPluginScope Comment
elseif Bundles('machakann/vim-patternjump')
  let g:patternjump_no_default_key_mappings = 1
elseif Bundles('lokaltog/vim-easymotion')
  let g:EasyMotion_leader_key = 'g<CR>'
elseif Bundles('-goldfeld/vim-seek', '-rhysd/clever-f.vim')
  let g:SeekKey = 'f<CR>'
  let g:SeekBackKey = 'f<BS>'
  " let g:seek_enable_jumps = 1
  let g:clever_f_across_no_line = 1
endif

" Create your own text objects
if BundleNow('kana/vim-textobj-user')
  call textobj#user#plugin('file', {
        \ 'file': {
        \ 'pattern': '\f\+', 'select': ['af', 'if']
        \ }
        \ })
endif

" Text objects extended
if Bundles('-wellle/targets.vim', 'kana/vim-textobj-indent',
      \ 'gaving/vim-textobj-argument', '-b4winckler/vim-angry',
      \ '-qstrahl/vim-dentures', 'tommcdo/vim-ninja-feet',
      \ 'machakann/vim-textobj-delimited', 'coderifous/textobj-word-column.vim')
  " Delay activating this bundle to reduce startup time
  set updatetime=10
  augroup bundle_targets
    autocmd CursorHold * call BundleActivate("targets.vim") |
          \ set updatetime& | autocmd! bundle_targets CursorHold
  augroup END
endif

" Insert: {{{1

" Provides insert mode auto-completion for quotes, parens, brackets, etc.
" Currently there're problems with 'repeat' or 'undo'.
call Bundles('-raimondi/delimitmate', '-cohama/lexima.vim', '-jiangmiao/auto-pairs')

" Wisely add 'end' in ruby, endfunction/endif/more in vim script, etc
call Bundles('tpope/vim-endwise')

" Completions
if has('lua') && Bundles('shougo/neocomplete.vim', 'bohrshaw/vimproc.vim')
  let g:neocomplete#enable_at_startup = 0
  let g:neocomplete#max_list = 20
  let g:neocomplete#auto_completion_start_length = 2
  let g:neocomplete#manual_completion_start_length = 1
  " let g:neocomplete#min_keyword_length = 3
  let g:neocomplete#enable_smart_case = &smartcase
  " let g:neocomplete#enable_cursor_hold_i = 1
  " let g:neocomplete#cursor_hold_i_time = 400 " same as swap saving interval
  let g:neocomplete#lock_iminsert = 1
  " let g:neocomplete#enable_prefetch = 1
  let g:neocomplete#data_directory = '~/.vim/tmp/neocomplete'
  " let g:neocomplete#release_cache_time = 1800 " seconds
  " Enable/disable neocomplete
  nnoremap <expr> <Leader>tC neocomplete#is_enabled() ?
        \ ':NeoCompleteDisable<CR>' : ':NeoCompleteEnable<CR>'
  " Toggle auto/manual completion for the current buffer
  nnoremap <Leader>tc :NeoCompleteToggle<CR>
  inoremap <LocalLeader>tc <C-R>=neocomplete#commands#_toggle_lock()[1:0]<CR>
  " Start manual completion
  inoremap <silent><M-n> <C-O>:call neocomplete#init#enable() \|
        \call neocomplete#commands#_lock() \|
        \inoremap <silent><expr><M-n> neocomplete#start_manual_complete()<CR>
        \<C-R>=neocomplete#start_manual_complete()<CR>
elseif Bundles('valloric/youcompleteme')
elseif Bundles('ervandew/supertab')
endif

" Snippet solutions
if (has('python') || has('python3')) && Bundle('Sirver/ultisnips',
      \ {'m':['i <C-J>'], 'c':'UltiSnipsEdit', 'f':'*.snippets'}) &&
      \ Bundles('Honza/vim-snippets')
  let g:UltiSnipsExpandTrigger='<C-J>'
  let g:UltiSnipsListSnippets='<C-Q>'
  let g:UltiSnipsJumpForwardTrigger="<C-J>"
  let g:UltiSnipsJumpBackwardTrigger="<C-K>"
  let g:UltiSnipsSnippetDirectories=["UltiSnips", "snippet"]
  let g:UltiSnipsSnippetsDir=expand("~/.vim/snippet") " personal snippets path
  " let g:UltiSnipsEditSplit="vertical"
  autocmd bundle BufNewFile,BufRead *.snippets set ft=snippets
  " Avoid python mis-detection during startup in Vim 7.4.52
  autocmd bundle VimEnter * if !has('python3') |
        \ let g:UltiSnipsUsePythonVersion = 2 | endif
elseif Bundles('garbas/vim-snipmate', 'marcweber/vim-addon-mw-utils',
      \ 'tomtom/tlib_vim', 'honza/vim-snippets')
  command! -nargs=1 SImap imap <args>|smap <args>
  SImap <C-J> <Plug>snipMateNextOrTrigger
  xmap <C-J> <Plug>snipMateVisual
  SImap <C-K> <Plug>snipMateBack
  inoremap <C-\> <C-K>
  SImap <C-Q> <Plug>snipMateShow
endif
let g:snips_author = 'Bohr Shaw'
let g:snips_author_email = 'pubohr@gmail.com'

" Change: {{{1

" Commenting
if Bundles('tpope/vim-commentary', '-scrooloose/nerdcommenter', '-tomtom/tcomment_vim')
  let commentary_map_backslash = 0 " jd
  let g:tcommentMapLeader1 = '<M-c>'
  let [g:tcommentMapLeader2, g:tcommentMapLeaderCommentAnyway, g:tcommentTextObjectInlineComment] = ['', '', '']
endif

" Quoting/parenthesizing made simple
call Bundles('Tpope/vim-surround')

" Alignment
if Bundles('-godlygeek/tabular', 'junegunn/vim-easy-align', '-tommcdo/vim-lion')
  command! -nargs=* -range -bang Align <line1>,<line2>EasyAlign <args>
  NXmap gl <Plug>(EasyAlign)
  NXmap gL <Plug>(LiveEasyAlign)
endif

" Use CTRL-A/CTRL-X to increment dates, times, and more
call Bundles('tpope/vim-speeddating')

" Exchange text flexibly with a text exchange operator
if Bundles('Tommcdo/vim-exchange')
  " nmap cx <Plug>(Exchange)
  vmap cx <Plug>(Exchange)
  " nmap cxc <Plug>(ExchangeClear)
  " nmap cxx <Plug>(ExchangeLine)
  nmap >w cxiwwcxiw
  nmap <w cxiwbcxiw
  nmap >W cxiWWcxiW
  nmap <W cxiWBcxiW
  nmap >a cxiaf,lcxia
  nmap <a cxiaF,hcxia
endif

" Exchange(swap) text directly/quickly with mappings
if Bundles('-kurkale6ka/vim-swap')
  " let g:swap_custom_ops = []
  xmap c: <plug>SwapSwapOperands
  xmap c\| <plug>SwapSwapPivotOperands
endif

" Easily search for, substitute, and abbreviate multiple variants of a word
call Bundles('Tpope/vim-abolish')

" True Sublime Text style multiple selections for Vim
call Bundles('kristijanhusak/vim-multiple-cursors')

" Preview contents of the registers when ", @, i_CTRL-R
" call Dundles('junegunn/vim-peekaboo')

" Characterize.vim: Unicode character metadata
call Bundles('tpope/vim-characterize')

" Transpose matrices of text (swap lines with columns)
" call Bundles('salsifis/vim-transpose')

" History: {{{1

" Display your undo history in a graph
if Bundles('-mbbill/undotree')
  nnoremap <Leader>tu :UndotreeToggle<CR>
  let g:undotree_SetFocusWhenToggle=1 " put cursor to undotree when togglling
endif

" Vim plugin to visualize your Vim undo tree
if Bundles('sjl/gundo.vim')
  nnoremap <Leader>tu :GundoToggle<CR>
endif

" Enable repeating supported plugin maps with '.'
call Bundles('Tpope/vim-repeat')

" A lightweight implementation of emacs's kill-ring for vim
" call Bundles('maxbrunsfeld/vim-yankstack')

" Mapping: {{{1

" Pairs of handy bracket mappings
if Bundles('Tpope/vim-unimpaired')
  nmap coP <Plug>unimpairedPaste
  " Mouse could also be enabld in Tmux
  nnoremap <silent> com :let &mouse = empty(&mouse) ? 'a' : ''<CR>
endif
nnoremap <silent> ]d :call search('\cto-\?do:', 's')<CR>
nnoremap <silent> [d :call search('\cto-\?do:', 'sb')<CR>

" Create your own submodes (e.g, g--- instead of g-g-g-)
" call BundleNow('kana/vim-submode')

" Mappings for simultaneously pressed keys
" call Bundles('kana/vim-arpeggio')

" Fixes key codes for console Vim
" call Bundles('drmikehenry/vim-fixkey')

" FileBufferPaneWindowTabSession: {{{1

" Fuzzy file, buffer, mru, tag, etc finder
if Bundles('ctrlpvim/ctrlp.vim')
  let g:ctrlp_cache_dir = $HOME.'/.vim/tmp/ctrlp'
  " Set the mode to determine the root searching directory.
  " let g:ctrlp_working_path_mode = 'ra'
  " let g:ctrlp_show_hidden = 1 " scan for dotfiles and dotdirs
  let g:ctrlp_follow_symlinks = 1
  " let g:ctrlp_clear_cache_on_exit = 0
  let g:ctrlp_max_files = 0
  let g:ctrlp_lazy_update = 99 " update the match window lazily
  " let g:ctrlp_by_filename = 1 " search by file name only
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/]\.(git|hg|svn)$',
        \ 'file': '\v\.(exe|so|dll)$'
        \ }
  " Specify an external tool to use for listing files.
  let s:ctrlp_git_cmd = 'cd %s && git ls-files && git ls-files -o --exclude-standard'
  let g:ctrlp_user_command = {
        \ 'types': {
        \ 1: ['.git', has('win32') ? '('.s:ctrlp_git_cmd.')' : s:ctrlp_git_cmd],
        \ 2: ['.hg', 'hg --cwd %s locate -I .'],
        \ },
        \ 'fallback': !has('win32') ?
        \ 'find %s -path "*/\.*" -prune -o -type f -print -o -type l -print' :
        \ executable('ag') ? 'ag %s -l --nocolor -g ""' : ''
        \ }
  " Bring up this finder in find file mode
  let g:ctrlp_map = '<M-p>'
  " let g:ctrlp_cmd = 'CtrlP'
  " Most recent used files
  nnoremap <Leader>fr :CtrlPMRU<CR>
  nnoremap <M-f> :CtrlPMRU<CR>
  " Files with similar names
  nmap <Leader>fs :let g:ctrlp_default_input = expand('%:t:r') \|
        \ call ctrlp#init(0) \| unlet g:ctrlp_default_input<CR>
  " Buffers
  nnoremap <M-b> :CtrlPBuffer<CR>
  " Files, buffers and MRU files at the same time
  nnoremap <Leader>fa :CtrlPMixed<CR>
  " Bookmarked directories
  nnoremap <leader>fm :CtrlPBookmarkDir<CR>
  " Clear the cache for the current search path
  nnoremap <leader>fc :CtrlPClearCache<CR>
  " fast matcher(especially for large projects) using python
  if 0 && has('python') && Bundles('felikz/ctrlp-py-matcher')
    let g:ctrlp_match_func = {'match': 'pymatcher#PyMatch'}
  elseif Bundles('tpope/vim-haystack') " better fuzzy matching algorithm
    function! Haystack_matcher(items, str, limit, mmode, ispath, crfile, regex) abort
      let items = copy(a:items)
      if a:ispath
        call filter(items, 'v:val !=# a:crfile')
      endif
      return haystack#filter(items, a:str)
    endfunction
    let g:ctrlp_match_func = {'match': 'Haystack_matcher'}
  endif
  " Extensions
  let g:ctrlp_extensions = []
  " Navigate and jump to function defs
  if Bundles('tacahiroy/ctrlp-funky')
    call add(g:ctrlp_extensions, 'funky')
    nnoremap <Leader>ff :CtrlPFunky<CR>
  endif
endif

" Unite and create user interfaces
if BundleNow('shougo/unite.vim')
  let g:unite_data_directory = expand('~/.vim/tmp/unite')
  call unite#filters#matcher_default#use(['matcher_fuzzy'])
  " let g:unite_source_history_yank_enable = 1
  if executable('ag')
    let g:unite_source_grep_command='ag'
    let g:unite_source_grep_default_opts='--smart-case --line-numbers --nogroup --nocolor'
    let g:unite_source_grep_recursive_opt=''
  endif
  command! -nargs=* -complete=customlist,unite#complete#source U Unite <args>
  " nnoremap <M-b> :Unite -no-split -quick-match buffer<CR>
  " Custom mappings for the unite buffer
  autocmd bundle FileType unite imap <buffer> <C-j> <Plug>(unite_select_next_line)|
        \ imap <buffer> <C-k> <Plug>(unite_select_previous_line)|
        \ imap <buffer> <C-q> <Plug>(unite_exit)
endif

" A tree explorer plugin for vim
if Bundle('scrooloose/nerdtree', {'m': [
      \ 'nnoremap <Leader>td :NERDTreeToggle<CR>',
      \ 'noremap <leader>dd :NERDTree<CR>',
      \ 'noremap <leader>df :NERDTreeFind<CR>']})
  let NERDTreeHijackNetrw=0 " don't replace netrw
  let NERDTreeBookmarksFile=$HOME.'/.vim/tmp/NERDTreeBookmarks'
  let NERDTreeIgnore=['^\.$', '^\.\.$', '\~$', '\.pyc$', '\.swp$']
  let NERDTreeShowHidden=1
  let NERDTreeShowBookmarks=1
  let NERDTreeQuitOnOpen=1
  let NERDTreeMouseMode=2
endif

" Convenient directory listing and file selection
if Bundles('tpope/vim-vinegar', '-jeetsukumaran/vim-filebeagle')
  nmap <M-d> <Plug>VinegarUp
  autocmd bundle VimEnter * nunmap -
endif

" Bookmarks independent from Vim marks
if Bundles('-mattesGroeger/vim-bookmarks')
  let g:bookmark_sign = 'm'
  let g:bookmark_annotation_sign = 'ma'
  " let g:bookmark_auto_save = 0
  let g:bookmark_auto_save_file = $HOME.'/.vim/tmp/bookmark'
  " let g:bookmark_highlight_lines = 1
  " let g:bookmark_center = 1
  nmap <Leader>tm <Plug>ToggleBookmark
  nmap ma <Plug>Annotate
  nmap ]m <Plug>NextBookmark
  nmap [m <Plug>PrevBookmark
  nmap <Leader>ml <Plug>ShowAllBookmarks
  nmap <Leader>mc <Plug>ClearBookmarks
  nmap <Leader>mC <Plug>ClearAllBookmarks
endif

" Project configuration
" call Bundles('tpope/vim-projectionist')

" Buffer Explorer/Browser
call Bundles('-vim-scripts/bufexplorer.zip', '-jeetsukumaran/vim-buffergator')

" Distraction-free, hyper-focus writing
if Bundles('Junegunn/goyo.vim', 'Junegunn/limelight.vim')
  " let g:goyo_width = 100
  let g:goyo_margin_top = 2
  let g:goyo_margin_bottom = 2
  " let g:goyo_linenr = 1
  nnoremap <C-W>O :Goyo<CR>
  autocmd bundle User GoyoEnter Limelight
  autocmd bundle User GoyoLeave Limelight!
endif

" Automatic resizing of Vim windows to the golden ratio
if Bundles('roman/golden-ratio')
  let g:golden_ratio_autocommand = 0
  noremap <C-W>G :GoldenRatioResize<CR>
endif

" Session management
if Bundles('bohrshaw/vim-mansion', '-tpope/vim-obsession')
  " let g:sessiondir = '~/.vim/session'
  " let g:mansion_no_auto_save = 1
  " let g:mansion_no_maps = 1
elseif Bundles('mhinz/vim-startify')
  let g:startify_session_dir = '~/.vim/tmp/session'
  let g:startify_list_order = ['sessions', 'bookmarks', 'files']
  let g:startify_skiplist = ['[Vv]im.*[\/]doc[\/][^\/]\+\.txt']
  let g:startify_custom_header = [
        \ '   _   /|',
        \ "   \\'o.O'",
        \ '   =(___)=',
        \ '      U    ʕϴϖϴʔ',
        \ ''
        \ ]
  " Prevent CtrlP open a split
  autocmd bundle FileType startify setlocal nospell buftype=
endif

" Appearance: {{{1

" Color Schemes
if Bundles('Junegunn/seoul256.vim', 'w0ng/vim-hybrid',
      \ 'reedes/vim-colors-pencil', 'freeo/vim-kalisi',
      \
      \ 'altercation/vim-colors-solarized', '-twerth/ir_black',
      \ 'Romainl/apprentice',
      \ 'nanotech/jellybeans.vim', 'Zeis/vim-kolor',
      \ 'jnurmine/zenburn', 'sjl/badwolf',
      \ 'goatslacker/mango.vim', 'Sk1418/last256',
      \ 'rking/vim-detailed', 'lokaltog/vim-distinguished',
      \ 'tomasr/molokai', 'sickill/vim-monokai',
      \ '-tpope/vim-vividchalk', '-vim-scripts/twilight') && Bundles(
      \
      \ 'endel/vim-github-colorscheme', 'jonathanfilip/vim-lucius',
      \ 'noahfrederick/vim-hemisu', 'morhetz/gruvbox',
      \
      \ '-flazz/vim-colorschemes', '-daylerees/colour-schemes/vim',
      \ 'chriskempson/vim-tomorrow-theme', 'chriskempson/base16-vim')
  let g:seoul256_background = 234
  let g:solarized_italic = 0
  let g:solarized_termcolors = &term =~ '256col' ? 256 : 16
  let g:solarized_menu=0
  autocmd bundle ColorScheme solarized runtime colors/solarized_additional.vim
endif
autocmd bundle VimEnter * nested execute 'color '.
      \ (has('gui_running') ? 'seoul256' :
      \ (has('win32') ? 'apprentice' : 'last256'))

" Make gvim-only colorschemes work transparently in terminal vim
" call Bundles('godlygeek/csapprox')

" Lean & mean statusline for vim that's light as air
if Bundles('-bling/vim-airline')
  " Remove separators, the different colors already make it easy to distinguish.
  let [g:airline_left_sep, g:airline_right_sep] = ['', '']
  " let g:airline_paste_symbol = 'P'
  let g:airline_section_z = '%l,%c %p%%' "right side section
  " Use shorter modes indicators
  let g:airline_mode_map = { '__': '-', 'n': 'N', 'i': 'I', 'R': 'R', 'c': 'C',
        \ 'v': 'V', 'V': 'VL', '': 'VB', 's': 'S', 'S': 'SL', '': 'SB'}
  " Extensions
  " Disable showing a summary of changed hunks under source control.
  let g:airline#extensions#hunks#enabled = 0
  " Showing only non-zero hunks.
  let g:airline#extensions#hunks#non_zero_only = 1
  " Disable detection of whitespace errors.
  let g:airline#extensions#whitespace#enabled = 0
  " Disable tagbar integration.
  let g:airline#extensions#tagbar#enabled = 0
endif

" Super simple vim plugin to show the list of buffers in the command bar
" call Bundles('bling/vim-bufferline')

" Toggle, display and navigate marks
if Bundles('-kshenoy/vim-signature')
  let g:SignatureEnabledAtStartup = 0
  let g:SignatureMenu = 0
endif

" Displaying indent levels visually
if Bundles('yggdroot/indentline', '-nathanaelkane/vim-indent-guides')
  let g:indentLine_enabled = 0
  let g:indentLine_fileTypeExclude = ['help']
  let g:indentLine_noConcealCursor = ''
  " let g:indentLine_fileType = ['rb']
  " let g:indentLine_faster = 1
  " let g:indentLine_char = '┊' " |│¦┆┊
  nnoremap <Leader>ti :IndentLinesToggle<CR>
endif

" A powerful color tool
call Bundles('-rykka/colorv.vim')

" All 256 xterm colors with their RGB equivalents, right in Vim!
call Bundle('guns/xterm-color-table.vim', {'c': 'XtermColorTable'})

" FileTypes: {{{1

" Mixed {{{2

" Syntax checking hacks for vim
if Bundles('scrooloose/syntastic')
  let g:syntastic_mode_map = { 'mode': 'active',
        \ 'active_filetypes': [],
        \ 'passive_filetypes': [] }
  let g:syntastic_auto_jump = 2 " auto-jump to the first error
endif

" Format codes with external code formatters
if Bundles('chiel92/vim-autoformat')
endif

" Vim plugin that displays tags in a window, ordered by class etc
if Bundles('majutsushi/tagbar')
  let g:tagbar_type_go = {
        \ 'ctagstype' : 'go',
        \ 'kinds' : [
        \ 'p:package', 'i:imports:1', 'c:constants', 'v:variables',
        \ 't:types', 'n:interfaces', 'w:fields', 'e:embedded',
        \ 'm:methods', 'r:constructor', 'f:functions'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : { 't' : 'ctype', 'n' : 'ntype' },
        \ 'scope2kind' : { 'ctype' : 't', 'ntype' : 'n' },
        \ 'ctagsbin' : 'gotags',
        \ 'ctagsargs' : '-sort -silent'
        \ }
  nnoremap <Leader>tt :TagbarToggle<CR>
endif

" Documentation/reference viewer
call Bundles('keithbsmiley/investigate.vim')

if Bundles('-thinca/vim-ref')
  let g:ref_no_default_key_mappings = 1
  nmap <silent> gK <Plug>(ref-keyword)
  vmap <silent> gK <Plug>(ref-keyword)
endif

" Dispatch.vim: asynchronous build and test dispatcher
call Bundles('tpope/vim-dispatch')

" Execute whole/part of editing file
if Bundles('thinca/vim-quickrun')
  let g:quickrun_config = {'_': {'outputter': 'message'}}
  let g:quickrun_no_default_key_mappings = 1
  nmap R <Plug>(quickrun-op)
  nnoremap <silent> RR :Run -mode n<CR>
  nnoremap R% :%QuickRun -mode n<CR>
  xnoremap R :QuickRun -mode v<CR>
  command! -nargs=* -range -complete=customlist,quickrun#complete Run
        \ call quickrun#command(<q-args>, <count>, <line1>, <line2>)
endif

" Transition between multiline and single-line code
if Bundles('andrewradev/splitjoin.vim')
  let g:splitjoin_split_mapping = 'gS'
  let g:splitjoin_join_mapping  = 'gJ'
endif

" Switch segments of text with predefined replacements
if Bundles('andrewradev/switch.vim')
  let g:switch_mapping = 'gs'
  " let g:switch_custom_definitions = []
endif

" Markups {{{2

" HTML5 omnicomplete and syntax
call Bundles('othree/html5.vim')

" Runtime files for Haml, Sass, and SCSS
call Bundles('tpope/vim-haml')

" Runtime files for LESS (dynamic CSS)
call Bundles('groenewege/vim-less')

" Improves HTML & CSS workflow: http://emmet.io
if Bundles('mattn/emmet-vim')
  let g:user_emmet_mode='i' " only enabled in insert mode
  let g:user_emmet_leader_key = '<M-e>' " mnemonic of 'expand'
  " let g:user_emmet_install_global = 0 " enabled only for certain file types
  " autocmd bundle FileType html,css EmmetInstall
endif

" Markdown runtime files
call Bundles('tpope/vim-markdown')

" Vim, your markup language of choice, and your browser of choice
" call Bundles('matthias-guenther/hammer.vim')

" Javascript {{{2

" Vastly improved Javascript indentation and syntax support
call Bundles('pangloss/vim-javascript')

" A plugin that integrates JSHint with Vim
" call Bundles('walm/jshint.vim')

" Tern plugin for vim(provides Tern-based JavaScript editing support)
" call Bundles('marijnh/tern_for_vim')

" CoffeeScript support for vim
call Bundles('kchmck/vim-coffee-script')

" C Family {{{2

if Bundles('rust-lang/rust.vim')
  let g:rust_fold = 1 " folds are defined but opened
  " let g:rust_conceal = 1
  autocmd bundle FileType rust nnoremap <buffer>R% :RustRun<CR>|
        \nnoremap <buffer>R<Space> :RustRun
endif

" Golang {{{2

if Bundles('fatih/vim-go', '-blackrush/vim-gocode')
  " let g:go_disable_autoinstall = 1
  let g:go_bin_path = has('win32unix') ?
        \ '/cygdrive/'.tolower($GOPATH[0]).substitute($GOPATH[2:], '\\', '/', 'g').'/bin/' :
        \ expand("$GOPATH/bin/")
  " let g:go_fmt_autosave = 0
  " call add(g:syntastic_mode_map['passive_filetypes'], 'go')
  autocmd bundle FileType go nnoremap <buffer> gd :GoDef<CR>|
        \ nnoremap <buffer> K :GoDoc<CR>|
        \ nnoremap <buffer> <LocalLeader>r :GoRun %<CR>|
        \ nnoremap <buffer> <LocalLeader>R :GoRun<CR>
  autocmd bundle FileType godoc nnoremap <buffer> q <C-W>q
endif

" Ruby {{{2

" Ruby runtime files (shipped with Vim and fairly updated.)
call Bundles('Vim-ruby/vim-ruby')

" A custom text object for selecting ruby blocks
call Bundle('Nelstrom/vim-textobj-rubyblock',
      \ {'f':'ruby', 'd':['kana/vim-textobj-user']})

" Provide more controls over the above
if Bundles('-rhysd/vim-textobj-ruby', '-kana/vim-textobj-user')
  let g:textobj_ruby_more_mappings = 1
endif

" Runs RuboCop(A robust Ruby code analyzer) and displays the results in Vim
if Bundles('ngmy/vim-rubocop')
  let g:vimrubocop_keymap = 0
  autocmd bundle FileType ruby nnoremap <silent> <buffer> <nowait>
        \ <LocalLeader>r :RuboCop<CR>
endif

" Bindings for the gem recording the results of every line of code
if Bundles('hwartig/vim-seeing-is-believing')
  autocmd bundle FileType ruby
        \ NXInoremap <buffer> <F5> <Plug>(seeing-is-believing-run)|
        \ NXInoremap <buffer> <F4> <Plug>(seeing-is-believing-mark)
endif

" Vim plugin for debugging Ruby applications (using ruby-debug-ide gem)
" call Bundles('astashov/vim-ruby-debugger')

" It's like rails.vim without the rails
call Bundle('tpope/vim-rake', {'f':'ruby'})

" Python {{{2

" Vim python-mode. PyLint, Rope, Pydoc, breakpoints from box.
if Bundles('klen/python-mode')
  let g:pymode_run_bind = '<LocalLeader>r'
  let g:pymode_breakpoint_bind = '<LocalLeader>b'
  let g:pymode_rope = 0
  " Escape syntastic check for python
  call add(get(get(g:, 'syntastic_mode_map', {}), 'passive_filetypes', []), 'python')
  " let g:pymode_python = 'python3'
  autocmd bundle VimEnter * set shellslash&
endif

" Bindings for the python auto-completion library 'jedi'
if Bundles('davidhalter/jedi-vim')
  let g:jedi#auto_vim_configuration = 0
  autocmd bundle FileType python setlocal completeopt=menuone,longest,preview
  let g:jedi#goto_assignments_command = '<LocalLeader>d'
  let g:jedi#goto_definitions_command = '<LocalLeader>D'
  let g:jedi#rename_command = '<LocalLeader>R'
  let g:jedi#usages_command = '<LocalLeader>U'
  let g:jedi#use_tabs_not_buffers = 0 " show definition in the current window
  let g:jedi#squelch_py_warning = 1 " suppress warning of -python
  let g:jedi#force_py_version = 3
endif

" A two-way integration between Vim and IPython 0.11+
call Bundles('-ivanov/vim-ipython')

" Java(JVM) {{{2

" Set 'path' from the Java class path
call Bundles('tpope/vim-classpath')

" My work on integration of Scala into Vim - not a ton here, but useful for me
" call Bundles('derekwyatt/vim-scala')

" Clojure {{{2

" Clojure runtime files (shipped with Vim versions 7.3.803+)
call Bundles('guns/vim-clojure-static')
" let g:clojure_fold = 1 " Fold list/vector/map that extends over multi-lines

" Clojure REPL tease
call Bundles('tpope/vim-fireplace')

" Static support for Leiningen
call Bundles('tpope/vim-leiningen')

" Precision Editing for S-expressions
call Bundles('guns/vim-sexp', 'tpope/vim-sexp-mappings-for-regular-people')

" Extend builtin syntax highlighting to referred and aliased vars
" call Bundles('guns/vim-clojure-highlight',
"       \ 'guns/vim-clojure-static', 'tpope/vim-fireplace')

" Better Rainbow Parentheses
if Bundles('jbnicolai/rainbow_parentheses.vim')
  let g:rbpt_loadcmd_toggle = 1
  autocmd bundle VimEnter * call rainbow_parentheses#load(0) |
        \ autocmd bundle Syntax clojure call rainbow_parentheses#load(0)
  autocmd bundle ColorScheme * call rainbow_parentheses#activate()
  nnoremap <Leader>tp :call rainbow_parentheses#toggle()<CR>
endif

" Others {{{2

" JSON runtime files
if Bundles('elzr/vim-json')
  autocmd bundle FileType json setlocal foldmethod=syntax
endif

" JSON manipulation and pretty printing
call Bundles('tpope/vim-jdaddy')
command! -range=% JSONFormat <line1>,<line2>!jq .
command! -range=% JSONFormatEncode <line1>,<line2>!python -m json.tool

" Git runtime files
call Bundles('tpope/vim-git')

" A Vim plugin for Windows PowerShell support
call Bundles('pprovost/vim-ps1')

" Syntax file for nginx
call Bundles('vim-scripts/nginx.vim')

" A mirror to the official vimperator's syntax file
call Bundles('bohrshaw/vim-vimperator-syntax')

" ExternalInteraction: {{{1

" An asynchronous execution library
if Bundles('bohrshaw/vimproc.vim')
  command! -nargs=+ -bang -complete=shellcmd B execute <bang>0 ?
        \ 'call vimproc#system_bg(<q-args>)' : 'VimProcBang <args>'
  command! -nargs=+ -complete=shellcmd R VimProcRead <args>
endif

" A powerful shell implemented in Vim Script
if has('nvim')
  " This command prefers an usually unique termianl-buffer-name compared with
  " the one('*:/usr/bin/zsh') created by :terminal.
  command! Shell let _b = bufname('^term://*:zsh$')|
        \if empty(_b)|enew|call termopen('zsh')|startinsert|
        \else|execute 'b '._b|endif
  NXnoremap <M-s> :<C-U>Shell<CR>
elseif Bundles('shougo/vimshell.vim', 'bohrshaw/vimproc.vim')
  NXnoremap <M-s> :<C-U>VimShell<CR>
  autocmd bundle FileType vimshell NXInoremap <buffer><silent><M-a> <Esc>:sil b#<CR>
endif

" The interface to Web API
if Bundles('mattn/webapi-vim')
  let g:webapi#system_function = has('win32') ?
        \ 'vimproc#cmd#system' : 'vimproc#system'
endif

" A Git wrapper so awesome, it should be illegal.
if Bundles('tpope/vim-fugitive')
  " Git deserves a convenient leader key for mappings
  nnoremap g<Space>s :Gstatus<CR>
  nnoremap g<Space>cc :Gcommit -v<CR>
  nnoremap g<Space>cC :call <SID>git_add_current() \| Gcommit -v<CR>
  nnoremap g<Space>CC :Gcommit --all -v<CR>
  nnoremap g<Space>ca :Gcommit --amend -v<CR>
  nnoremap g<Space>cA :call <SID>git_add_current() \| Gcommit --amend -v<CR>
  nnoremap g<Space>CA :Gcommit --all --amend -v<CR>
  nnoremap g<Space>ce :Gcommit --allow-empty-message -m ''<CR>
  nnoremap g<Space>cE :call <SID>git_add_current() \| Gcommit --allow-empty-message -m ''<CR>
  nnoremap g<Space>CE :Gcommit --all --allow-empty-message -m ''<CR>
  nnoremap g<Space>cd :wq \| Gcommit -v<CR>
  nnoremap g<Space>dd <C-W>o:Gdiff<CR>
  nnoremap g<Space>da :Git diff<CR>
  nnoremap g<Space>b :Gblame<CR>
  nnoremap g<Space>l :Glog<CR>
  nnoremap g<Space>ps :GGit push<CR>
  nnoremap g<Space>pS :GGit push -f<CR>
  nnoremap g<Space>pl :GGit pull<CR>
  nnoremap <silent> <Leader>dr :execute 'lcd '.b:git_dir[:-6]<CR>
  nnoremap <silent> <Leader>dR :execute 'cd '.b:git_dir[:-6]<CR>
  " Utilities
  function! s:git_file_path()
    return expand('%:p')[len(b:git_dir)-4:]
  endfunction
  function! s:git_add_current()
    execute &modified ? 'w' : ''
    call fugitive#repo().git_chomp_in_tree('add', s:git_file_path())
  endfunction
  " Asynchronous execution
  command! -nargs=1 GGit call vimproc#system_bg('git --git-dir='.b:git_dir.' <args>')
endif

" Git branch management
if Bundles('-sodapopcan/vim-twiggy') && Bundles('tpope/vim-fugitive')
endif

" A git repository viewer(a gitk clone)
if Bundle('gregsexton/gitv', {'c': 'Gitv'}) && Bundles('tpope/vim-fugitive')
endif

" Shows a git diff in the sign column and stages/reverts hunks
if Bundles('airblade/vim-gitgutter')
  " let g:gitgutter_enabled = 0
  " let g:gitgutter_signs = 0
  let g:gitgutter_realtime = 0
  let g:gitgutter_eager = 0
  " let g:gitgutter_diff_args = '-w'
  " let g:gitgutter_highlight_lines = 1
  let g:gitgutter_sign_removed = '-'
  let g:gitgutter_sign_modified_removed = '='
  let g:gitgutter_map_keys = 0
  nnoremap g<Space>ds :call gitgutter#toggle()<CR>
  nnoremap g<Space>u :GitGutter<CR>
  nnoremap g<Space>U :GitGutterAll<CR>
  nmap [c <Plug>GitGutterPrevHunk
  nmap ]c <Plug>GitGutterNextHunk
  nmap <silent> dp :execute &diff ? 'diffput' : 'GitGutterStageHunk'<CR>
  nmap <silent> do :execute &diff ? 'diffget' : 'GitGutterRevertHunk'<CR>
  nmap dP :GitGutterPreviewHunk<CR>
endif

" Show a VCS diff using Vim's sign column
if Bundles('-mhinz/vim-signify')
  " let g:signify_disable_by_default = 1
  let g:signify_vcs_list = ['git']
  let g:signify_sign_delete = '-'
endif

" Browse GitHub events
if Bundles('junegunn/vim-github-dashboard')
  let g:github_dashboard = {'username': 'bohrshaw'}
  nnoremap g<Space>G :GHDashboard!<CR>
  nnoremap g<Space>A :GHActivity!<CR>
endif

" Helpers for UNIX(Windows)
if Bundles('tpope/vim-eunuch')
  autocmd bundle VimEnter * command! W SudoWrite
endif

" Tmux basics, insert mode completion of words in adjacent tmux panes
if !has('win32') && Bundles('tpope/vim-tbone', 'wellle/tmux-complete.vim')
  let g:tmuxcomplete#trigger = '' " completefunc, omnifunc, or empty
endif

" Implement transparent editing of gpg encrypted files
if Dundles('jamessan/vim-gnupg') " a huge plugin file
  let g:GPGDefaultRecipients = ['Bohr Shaw']
  command! -bar GPGEnable call BundleActivate('vim-gnupg')
  command! GPGDone let &viminfo = _viminfo
  command! Diary execute (exists("g:loaded_gnupg") ? '' : 'GPGEnable|').
        \ 'silent e '.get(g:, 'DIARY_PATH', '').strftime('%Y%m%d').'.gpg|'.
        \ 'silent! wincmd c|setlocal nolinebreak|Goyo'
endif

" Translation
if Bundles('bohrshaw/vim-trance', 'mattn/webapi-vim')
  " let g:trance#default = 'iciba'
  " Translation services
  let g:trance = {
        \ 'youdao': 'key=1387543717&keyfrom=vim-translate',
        \ 'baidu': 'client_id=OjbuMOjZUwHtxcnxblAoQzds',
        \ }
  " let g:trance#youdao_target = 'dict' " 'translate', 'dict' or ''(both)
  " let g:trance#truncate = 0 " truncate long output to be unobtrusive
  NXmap <Leader>T <Plug>trance
endif

" URL shortener
call Bundles('bohrshaw/vim-url-shortener')

" Open URI with your favorite browser
" Other ways:
" - The builtin function 'netrw#NetrwBrowseX()' (not working currently)
" - Python helpers: :py import webbrowser; webbrowser.open()
if Bundles('tyru/open-browser.vim')
  " Add or override search engines
  let g:openbrowser_search_engines = {
        \ 'google_hk': 'http://google.com.hk/search?q={query}',
        \ 'baidu': 'http://www.baidu.com/s?wd={query}',
        \ 'so': 'http://www.so.com/s?q={query}',
        \ 'translate': 'http://translate.google.com.hk/#auto/zh-CN/{query}',
        \ 'stackoverflow': 'http://stackoverflow.com/search?q={query}',
        \ }
  let g:openbrowser_default_search = 'google_hk'
  let g:netrw_nogx = 1 " disable netrw's gx mapping
  " Search the focused word or the selection via the Web
  nmap gx <Plug>(openbrowser-smart-search)
  xmap gx <Plug>(openbrowser-smart-search)
  " Remove unused commands
  autocmd bundle VimEnter * delcommand OpenBrowser | delcommand OpenBrowserSearch
endif

" Vimscript for gist
if Bundles('mattn/gist-vim', 'mattn/webapi-vim')
  let g:gist_post_private = 1
endif

" Run code on codepad.org
if Bundles('mattn/codepad-vim', 'mattn/webapi-vim')
  NXnoremap <Leader>R :CodePadRun<CR>
endif

" Interact with the simplenote service
" call Bundles('mrtazz/simplenote.vim')

" Browse Hacker News inside Vim, :pip install hackernews-python
if Dundles('ryanss/vim-hackernews')
  command! HackerNews call BundleActivate('vim-hackernews') |HackerNews
endif

" AlternativeUsages: {{{1

" Personal Wiki for Vim
if Bundles('-vimwiki/vimwiki')
  " Restrict vimwiki's operation to only those paths listed in g:vimwiki_list.
  let g:vimwiki_global_ext = 0
  " Don't conceal characters
  let g:vimwiki_conceallevel = 0
  " Register one or more wikis
  let g:vimwiki_list = [{'path': '~/vimwiki/',
        \ 'syntax': 'markdown',
        \ 'ext': '.md'}]
endif

" A calendar application
if Bundles('itchyny/calendar.vim')
  " let g:calendar_google_calendar = 1
  " let g:calendar_google_task = 1
endif

" A convenient interactive calculator inside a buffer
call Bundle('gregsexton/vimcalc', {'c': 'Calc'})

" Task managers
" call Bundles('aaronbieber/quicktask', 'davidoc/taskpaper.vim',
"       \ 'davidoc/todo.txt-vim')

" vim:ft=vim tw=80 et sw=2 fdm=marker cms="\ %s:
